---
sidebar_position: 2
---

# credit-manager

## Links

- **Deployments**: https://github.com/mars-protocol/rover/tree/master/scripts/deploy/addresses
- **Types**:
    - **Rust**: https://github.com/mars-protocol/v2-fields-of-mars/tree/master/packages/rover/src/msg
    - **Typescript**: https://github.com/mars-protocol/v2-fields-of-mars/tree/master/scripts/types/generated/mars-credit-manager
- **Contract repo**: https://github.com/mars-protocol/v2-fields-of-mars/tree/master/contracts/credit-manager
- **Audits**: https://github.com/mars-protocol/mars-audits/tree/main/rover

## InstantiateMsg

<CH.Section>
    <CH.Code>

        {/* ```json json
        {
            "owner": "...",
            "allowed_coins": [
                "...", 
                "...", 
                etc...
            ],
            "vault_configs": [
                {
                    "vault": {
                        "address": "..."
                    }, 
                    "config": {
                        "deposit_cap": {
                            "denom": "...", 
                            "amount": "123"
                        },
                        "max_ltv": "0.123",
                        "liquidation_threshold": "0.123",
                        "whitelisted": true,  
                    }
                }, 
                etc...
            ],
            "red_bank": "...",
            "oracle": "...",
            "max_close_factor": "0.123",
            "max_unlocking_positions": "123",
            "swapper": "...",
            "zapper": "..."
        }
        ``` */}

        ```typescript types.ts
        type Decimal = string
        type Uint128 = string
        type OracleBaseForString = string
        type RedBankBaseForString = string
        type SwapperBaseForString = string
        type ZapperBaseForString = string

        interface InstantiateMsg {
            allowed_coins: string[]
            max_close_factor: Decimal
            max_unlocking_positions: Uint128
            oracle: OracleBaseForString
            owner: string
            red_bank: RedBankBaseForString
            swapper: SwapperBaseForString
            vault_configs: VaultInstantiateConfig[]
            zapper: ZapperBaseForString
        }
        ```

        {/* ```rust instantiate.rs
        #[cw_serde]
        pub struct InstantiateMsg {
            /// The address with privileged access to update config
            pub owner: String,
            /// Whitelisted coin denoms approved by governance
            pub allowed_coins: Vec<String>,
            /// Vaults approved by governance that implement credit manager's vault interface
            /// Includes a deposit cap that enforces a TLV limit for risk mitigation
            pub vault_configs: Vec<VaultInstantiateConfig>,
            /// The Mars Protocol money market contract where we borrow assets from
            pub red_bank: RedBankUnchecked,
            /// The Mars Protocol oracle contract. We read prices of assets here.
            pub oracle: OracleUnchecked,
            /// The maximum percent a liquidator can decrease the debt amount of the liquidatee
            pub max_close_factor: Decimal,
            /// The maximum number of unlocking positions an account can have simultaneously
            /// Note: As health checking requires looping through each, this number must not be too large.
            ///       If so, having too many could prevent the account from being liquidated due to gas constraints.
            pub max_unlocking_positions: Uint128,
            /// Helper contract for making swaps
            pub swapper: SwapperUnchecked,
            /// Helper contract for adding/removing liquidity
            pub zapper: ZapperUnchecked,
        }
        ``` */}

    </CH.Code>
</CH.Section>

#### `VaultInstantiateConfig`

<CH.Section>
    <CH.Code>

        ```ts types.ts
        interface VaultInstantiateConfig {
            config: VaultConfig
            vault: VaultBaseForString
        }
        ```

        {/* ```json json
        {
            "vault": {
                "address": "..."
            }, 
            "config": {
                "deposit_cap": {
                    "denom": "...", 
                    "amount": "123"
                },
                "max_ltv": "0.123",
                "liquidation_threshold": "0.123",
                "whitelisted": true,  
            }
        }
        ```

        ```rust instantiate.rs
        #[cw_serde]
        pub struct VaultInstantiateConfig {
            pub vault: VaultUnchecked,
            pub config: VaultConfig,
        }
        ``` */}

    </CH.Code>
</CH.Section>

#### `VaultConfig`

<CH.Section>
    <CH.Code>

        ```ts types.ts
        interface VaultConfig {
            deposit_cap: Coin
            liquidation_threshold: Decimal
            max_ltv: Decimal
            whitelisted: boolean
        }
        ```

        {/* ```json json
        {
            "deposit_cap": {
                "denom": "...", 
                "amount": "123"
            },
            "max_ltv": "0.123",
            "liquidation_threshold": "0.123",
            "whitelisted": true,  
        }
        ```

        ```rust config.rs
        #[cw_serde]
        pub struct VaultConfig {
            pub deposit_cap: Coin,
            pub max_ltv: Decimal,
            pub liquidation_threshold: Decimal,
            pub whitelisted: bool,
        }
        ``` */}

    </CH.Code>
</CH.Section>

#### `Coin`

<CH.Section>
    <CH.Code>

        ```ts types.ts
        interface VaultConfig {
            deposit_cap: Coin
            liquidation_threshold: Decimal
            max_ltv: Decimal
            whitelisted: boolean
        }
        ```

    </CH.Code>
</CH.Section>


#### `VaultBaseForString`

<CH.Section>
    <CH.Code>

        ```ts types.ts
        interface VaultBaseForString {
            address: string
        }
        ```

    </CH.Code>
</CH.Section>

## ExecuteMsg

### `create_credit_account`

Mints NFT representing a credit account for user. User can have many.

<CH.Section>
    <CH.Code>

        ```ts types.ts
        type ExecuteMsg =
            {
                create_credit_account: {}
            }
        ```

        {/* ```json json
        {
            "create_credit_account": {}
        }
        ```

        ```rust execute.rs
        #[cw_serde]
        pub enum ExecuteMsg {
            CreateCreditAccount {},
            UpdateCreditAccount {
                account_id: String,
                actions: Vec<Action>,
            },
            UpdateConfig {
                updates: ConfigUpdates,
            },
            UpdateOwner(OwnerUpdate),
            UpdateNftConfig {
                updates: NftConfigUpdates,
            },
            Callback(CallbackMsg),
        }
        ``` */}

    </CH.Code>
</CH.Section>

### `update_credit_account`

Update user's position on their credit account.

<CH.Section>
    <CH.Code>

        ```ts types.ts
        type ExecuteMsg =
            {
                update_credit_account: {
                    account_id: string
                    actions: Action[]
                }
            }
        ```

        {/* ```json json
        {
            "update_credit_account": {
                "account_id": "...", 
                "actions": [
                    {
                        "enter_vault": {
                            "vault": {
                                "address": "..."
                            }, 
                            "coin": {
                                "denom": "...", 
                                "amount": {
                                    "exact": "12345"
                                }
                            }
                        }
                    }, 
                    etc...
                ]
            }
        }
        ```

        ```rust execute.rs
        #[cw_serde]
        pub enum ExecuteMsg {
            CreateCreditAccount {},
            UpdateCreditAccount {
                account_id: String,
                actions: Vec<Action>,
            },
            UpdateConfig {
                updates: ConfigUpdates,
            },
            UpdateOwner(OwnerUpdate),
            UpdateNftConfig {
                updates: NftConfigUpdates,
            },
            Callback(CallbackMsg),
        }
        ``` */}

    </CH.Code>
</CH.Section>

#### `Action`

<CH.Section>
    <CH.Code>

        ```ts types.ts
        type Action =
        |   {
                deposit: Coin
            }
        |   {
                withdraw: Coin
            }
        |   {
                borrow: Coin
            }
        |   {
                repay: ActionCoin
            }
        |   {
                enter_vault: {
                    coin: ActionCoin
                    vault: VaultBaseForString
                }
            }
        |   {
                exit_vault: {
                    amount: Uint128
                    vault: VaultBaseForString
                }
            }
        |   {
                request_vault_unlock: {
                    amount: Uint128
                    vault: VaultBaseForString
                }
            }
        |   {
                exit_vault_unlocked: {
                    id: number
                    vault: VaultBaseForString
                }
            }
        |   {
                liquidate_coin: {
                    debt_coin: Coin
                    liquidatee_account_id: string
                    request_coin_denom: string
                }
            }
        |   {
                liquidate_vault: {
                    debt_coin: Coin
                    liquidatee_account_id: string
                    position_type: VaultPositionType
                    request_vault: VaultBaseForString
                }
            }
        |   {
                swap_exact_in: {
                    coin_in: ActionCoin
                    denom_out: string
                    slippage: Decimal
                }
            }
        |   {
                provide_liquidity: {
                    coins_in: ActionCoin[]
                    lp_token_out: string
                    minimum_receive: Uint128
                }
            }
        |   {
                withdraw_liquidity: {
                    lp_token: ActionCoin
                }
            }
        |   {
                refund_all_coin_balances: {}
            }
        ```

{/* 
        ```rust execute.rs
        #[cw_serde]
        pub enum Action {
            /// Deposit coin of specified denom and amount. Verifies if the correct amount is sent with transaction.
            Deposit(Coin),
            /// Withdraw coin of specified denom and amount
            Withdraw(Coin),
            /// Borrow coin of specified amount from Red Bank
            Borrow(Coin),
            /// Repay coin of specified amount back to Red Bank. If `amount: AccountBalance` is passed,
            /// the repaid amount will be the minimum between account balance for denom and total owed.
            Repay(ActionCoin),
            /// Deposit coins into vault strategy
            /// If `coin.amount: AccountBalance`, Rover attempts to deposit the account's entire balance into the vault
            EnterVault {
                vault: VaultUnchecked,
                coin: ActionCoin,
            },
            /// Withdraw underlying coins from vault
            ExitVault {
                vault: VaultUnchecked,
                amount: Uint128,
            },
            /// Requests unlocking of shares for a vault with a required lock period
            RequestVaultUnlock {
                vault: VaultUnchecked,
                amount: Uint128,
            },
            /// Withdraws the assets for unlocking position id from vault. Required time must have elapsed.
            ExitVaultUnlocked {
                id: u64,
                vault: VaultUnchecked,
            },
            /// Pay back debt of a liquidatable rover account for a bonus. Requires specifying 1) the debt
            /// denom/amount of what the liquidator wants to payoff and 2) the request coin denom which the
            /// liquidatee should have a balance of. The amount returned to liquidator will be the request coin
            /// of the amount that precisely matches the value of the debt + a liquidation bonus.
            /// The debt amount will be adjusted down if:
            /// - Exceeds liquidatee's total debt for denom
            /// - Not enough liquidatee request coin balance to match
            /// - The value of the debt repaid exceeds the maximum close factor %
            LiquidateCoin {
                /// The credit account id of the one with a liquidation threshold health factor 1 or below
                liquidatee_account_id: String,
                /// The coin debt that the liquidator wishes to pay back on behalf of the liquidatee.
                /// The liquidator must already have these assets in their credit account.
                debt_coin: Coin,
                /// The coin they wish to acquire from the liquidatee (amount returned will include the bonus)
                request_coin_denom: String,
            },
            /// Pay back debt of a liquidatable rover account for a via liquidating a vault position.
            /// Similar to LiquidateCoin {} msg and will make similar adjustments to the request.
            /// The vault position will be withdrawn (and force withdrawn if a locked vault position) and
            /// the underlying assets will transferred to the liquidator.
            /// The `VaultPositionType` will determine which bucket to liquidate from.
            LiquidateVault {
                liquidatee_account_id: String,
                debt_coin: Coin,
                request_vault: VaultUnchecked,
                position_type: VaultPositionType,
            },
            /// Perform a swapper with an exact-in amount. Requires slippage allowance %.
            /// If `coin_in.amount: AccountBalance`, the accounts entire balance of `coin_in.denom` will be used.
            SwapExactIn {
                coin_in: ActionCoin,
                denom_out: String,
                slippage: Decimal,
            },
            /// Add Vec<Coin> to liquidity pool in exchange for LP tokens
            ProvideLiquidity {
                coins_in: Vec<ActionCoin>,
                lp_token_out: String,
                minimum_receive: Uint128,
            },
            /// Send LP token and withdraw corresponding reserve assets from pool.
            /// If `lp_token.amount: AccountBalance`, the account balance of `lp_token.denom` will be used.
            WithdrawLiquidity {
                lp_token: ActionCoin,
            },
            /// Refunds all coin balances back to user wallet
            RefundAllCoinBalances {},
        }
        ``` */}

    </CH.Code>
</CH.Section>


#### `ActionCoin`

<CH.Section>
    <CH.Code>

        ```ts types.ts
        interface ActionCoin {
            amount: ActionAmount
            denom: string
        }
        ```

    </CH.Code>
</CH.Section>


#### `ActionAmount`

<CH.Section>
    <CH.Code>

        ```ts types.ts
        type ActionAmount =
        |   'account_balance'
        |   {
                exact: Uint128
            }
        ```

    </CH.Code>
</CH.Section>

#### `VaultPositionType`

<CH.Section>
    <CH.Code>

        ```ts types.ts
        type VaultPositionType = 'u_n_l_o_c_k_e_d' | 'l_o_c_k_e_d' | 'u_n_l_o_c_k_i_n_g'
        ```

    </CH.Code>
</CH.Section>

### `update_config`

Update contract config constants. 

<CH.Section>
    <CH.Code>

        ```ts types.ts
        type ExecuteMsg =
            {
                update_config: {
                    updates: ConfigUpdates
                }
            }
        ```

{/* 
        ```json json
        {
            "update_config": {
                "updates": {
                    "account_nft": "...",
                    "allowed_coins": [ "...", "...", "..." ],
                    "pvault_configs": [
                        {
                            "vault": {
                                "address": "..."
                            }, 
                            "config": {
                                "deposit_cap": {
                                    "denom": "...", 
                                    "amount": "123"
                                },
                                "max_ltv": "0.123",
                                "liquidation_threshold": "0.123",
                                "whitelisted": true,  
                            }
                        }
                    ]
                    "oracle": "...",
                    "max_close_factor": "0.123",
                    "max_unlocking_positions": "123",
                    "swapper": "...",
                    "zapper": "..."
                }
            }
        }
        ```

        ```rust execute.rs
        #[cw_serde]
        pub enum ExecuteMsg {
            CreateCreditAccount {},
            UpdateCreditAccount {
                account_id: String,
                actions: Vec<Action>,
            },
            UpdateConfig {
                updates: ConfigUpdates,
            },
            UpdateOwner(OwnerUpdate),
            UpdateNftConfig {
                updates: NftConfigUpdates,
            },
            Callback(CallbackMsg),
        }
        ``` */}

    </CH.Code>
</CH.Section>


#### `ConfigUpdates` 

Used when you want to update fields on Instantiate config.

        ```ts types.ts
        interface ConfigUpdates {
            account_nft?: string | null
            allowed_coins?: string[] | null
            max_close_factor?: Decimal | null
            max_unlocking_positions?: Uint128 | null
            oracle?: OracleBaseForString | null
            swapper?: SwapperBaseForString | null
            vault_configs?: VaultInstantiateConfig[] | null
            zapper?: ZapperBaseForString | null
        }
        ```

        {/* ```json json
        {
            "account_nft": "...",
            "allowed_coins": [ "...", "...", "..." ],
            "pvault_configs": [
                {
                    "vault": {
                        "address": "..."
                    }, 
                    "config": {
                        "deposit_cap": {
                            "denom": "...", 
                            "amount": "123"
                        },
                        "max_ltv": "0.123",
                        "liquidation_threshold": "0.123",
                        "whitelisted": true,  
                    }
                }
            ]
            "oracle": "...",
            "max_close_factor": "0.123",
            "max_unlocking_positions": "123",
            "swapper": "...",
            "zapper": "..."
        }
        ```

        ```rust instantiate.rs
        #[cw_serde]
        #[derive(Default)]
        pub struct ConfigUpdates {
            pub account_nft: Option<String>,
            pub allowed_coins: Option<Vec<String>>,
            pub vault_configs: Option<Vec<VaultInstantiateConfig>>,
            pub oracle: Option<OracleUnchecked>,
            pub max_close_factor: Option<Decimal>,
            pub max_unlocking_positions: Option<Uint128>,
            pub swapper: Option<SwapperUnchecked>,
            pub zapper: Option<ZapperUnchecked>,
        }
        ``` */}

### `update_owner`

Manages owner role state. 

<CH.Section>
    <CH.Code>

        ```ts types.ts
        type ExecuteMsg =
            {
                update_owner: OwnerUpdate
            }
        ```



        // ```json json
        // {
        //     "update_owner": {
        //         "propose_new_owner": {
        //             "proposed": "..."
        //         }
        //     }
        // }
        // ```

        // ```rust execute.rs
        // #[cw_serde]
        // pub enum ExecuteMsg {
        //     CreateCreditAccount {},
        //     UpdateCreditAccount {
        //         account_id: String,
        //         actions: Vec<Action>,
        //     },
        //     UpdateConfig {
        //         updates: ConfigUpdates,
        //     },
        //     UpdateOwner(OwnerUpdate),
        //     UpdateNftConfig {
        //         updates: NftConfigUpdates,
        //     },
        //     Callback(CallbackMsg),
        // }
        // ```

    </CH.Code>
</CH.Section>

#### `OwnerUpdate`

<CH.Section>
    <CH.Code>

        ```ts types.ts
        type OwnerUpdate =
        |   {
                propose_new_owner: {
                    proposed: string
                }
            }
        |   'clear_proposed'
        |   'accept_proposed'
        |   'abolish_owner_role'
        ```

        {/* ```rust mars_owner
        pub enum OwnerUpdate {
            ProposeNewOwner {
                proposed: String,
            },
            ClearProposed,
            AcceptProposed,
            AbolishOwnerRole,
        }
        ``` */}

    </CH.Code>
</CH.Section>

### `update_nft_config`

Update nft contract config. 

<CH.Section>
    <CH.Code>

        ```ts types.ts
        type ExecuteMsg =
            {
                update_nft_config: {
                    updates: NftConfigUpdates
                }
            }
        ```

        {/* ```json json
        {
            "update_nft_config": {
                "updates": {
                    "max_value_for_burn": "12345", 
                    "proposed_new_minter": "..."
                }
            }
        }
        ```

        ```rust execute.rs
        #[cw_serde]
        pub enum ExecuteMsg {
            CreateCreditAccount {},
            UpdateCreditAccount {
                account_id: String,
                actions: Vec<Action>,
            },
            UpdateConfig {
                updates: ConfigUpdates,
            },
            UpdateOwner(OwnerUpdate),
            UpdateNftConfig {
                updates: NftConfigUpdates,
            },
            Callback(CallbackMsg),
        }
        ``` */}

    </CH.Code>
</CH.Section>

#### `NftConfigUpdates`

<CH.Section>
    <CH.Code>

        ```ts types.ts
        interface NftConfigUpdates {
            max_value_for_burn?: Uint128 | null
            proposed_new_minter?: string | null
        }
        ```

        {/* ```json json
        {
            "max_value_for_burn": "12345", 
            "proposed_new_minter": "..."
        }
        ```

        ```rust nft_config.rs
        #[cw_serde]
        pub struct NftConfigUpdates {
            pub max_value_for_burn: Option<Uint128>,
            pub proposed_new_minter: Option<String>,
        }
        ``` */}

    </CH.Code>
</CH.Section>

### `callback`

Internal actions only callable by the contract itself.

<CH.Section>
    <CH.Code>

        ```ts types.ts
        type ExecuteMsg =
            {
                callback: CallbackMsg
            }
        ```

        {/* ```json json
        {
            "callback": {
                "enter_vault": {
                    "account_id": "...", 
                    "vault": {
                        "address": "..."
                    }, 
                    "coin": {
                        "denom": "...", 
                        "amount": {
                            "exact": "..."
                        }
                    }
                }
            }
        }
        ```

        ```rust execute.rs
        #[cw_serde]
        pub enum ExecuteMsg {
            CreateCreditAccount {},
            UpdateCreditAccount {
                account_id: String,
                actions: Vec<Action>,
            },
            UpdateConfig {
                updates: ConfigUpdates,
            },
            UpdateOwner(OwnerUpdate),
            UpdateNftConfig {
                updates: NftConfigUpdates,
            },
            Callback(CallbackMsg),
        }
        ``` */}

    </CH.Code>
</CH.Section>

#### `CallbackMsg`

Internal actions made by the contract with pre-validated inputs.

<CH.Section>
    <CH.Code>

        ```ts types.ts
        type Addr = string

        type CallbackMsg =
        |   {
                withdraw: {
                    account_id: string
                    coin: Coin
                    recipient: Addr
                }
            }
        |   {
                borrow: {
                    account_id: string
                    coin: Coin
                }
            }
        |   {
                repay: {
                    account_id: string
                    coin: ActionCoin
                }
            }
        |   {
                assert_max_ltv: {
                    account_id: string
                    prev_health: Health
                }
            }
        |   {
                enter_vault: {
                    account_id: string
                    coin: ActionCoin
                    vault: VaultBaseForAddr
                }
            }
        |   {
                exit_vault: {
                    account_id: string
                    amount: Uint128
                    vault: VaultBaseForAddr
                }
            }
        |   {
                update_vault_coin_balance: {
                    account_id: string
                    previous_total_balance: Uint128
                    vault: VaultBaseForAddr
                }
            }
        |   {
                request_vault_unlock: {
                    account_id: string
                    amount: Uint128
                    vault: VaultBaseForAddr
                }
            }
        |   {
                exit_vault_unlocked: {
                    account_id: string
                    position_id: number
                    vault: VaultBaseForAddr
                }
            }
        |   {
                liquidate_coin: {
                    debt_coin: Coin
                    liquidatee_account_id: string
                    liquidator_account_id: string
                    request_coin_denom: string
                }
            }
        |   {
                liquidate_vault: {
                    debt_coin: Coin
                    liquidatee_account_id: string
                    liquidator_account_id: string
                    position_type: VaultPositionType
                    request_vault: VaultBaseForAddr
                }
            }
        |   {
                swap_exact_in: {
                    account_id: string
                    coin_in: ActionCoin
                    denom_out: string
                    slippage: Decimal
                }
            }
        |   {
                update_coin_balance: {
                    account_id: string
                    previous_balance: Coin
                }
            }
        |   {
                provide_liquidity: {
                    account_id: string
                    coins_in: ActionCoin[]
                    lp_token_out: string
                    minimum_receive: Uint128
                }
            }
        |   {
                withdraw_liquidity: {
                    account_id: string
                    lp_token: ActionCoin
                }
            }
        |   {
                assert_one_vault_position_only: {
                    account_id: string
                }
            }
        |   {
                refund_all_coin_balances: {
                    account_id: string
                }
            }
        ```

        {/* ```rust execute.rs
        #[cw_serde]
        pub enum CallbackMsg {
            /// Withdraw specified amount of coin from credit account;
            /// Decrement the token's asset amount;
            Withdraw {
                account_id: String,
                coin: Coin,
                recipient: Addr,
            },
            /// Borrow specified amount of coin from Red Bank;
            /// Increase the token's coin amount and debt shares;
            Borrow {
                account_id: String,
                coin: Coin,
            },
            /// Repay coin of specified amount back to Red Bank;
            /// Decrement the token's coin amount and debt shares;
            /// If `coin.amount: AccountBalance` is passed, the repaid amount will be the minimum
            /// between account balance for denom and total owed;
            Repay {
                account_id: String,
                coin: ActionCoin,
            },
            /// Assert MaxLTV is either:
            /// - Healthy, if prior to actions MaxLTV health factor >= 1 or None
            /// - Not further weakened, if prior to actions MaxLTV health factor < 1
            /// Emits a `position_changed` event.
            #[serde(rename = "assert_max_ltv")]
            AssertMaxLTV {
                prev_health: Health,
                account_id: String,
            },
            /// Adds coin to a vault strategy
            EnterVault {
                account_id: String,
                vault: Vault,
                coin: ActionCoin,
            },
            /// Exchanges vault LP shares for assets
            ExitVault {
                account_id: String,
                vault: Vault,
                amount: Uint128,
            },
            /// Used to update the account balance of vault coins after a vault action has taken place
            UpdateVaultCoinBalance {
                vault: Vault,
                /// Account that needs vault coin balance adjustment
                account_id: String,
                /// Total vault coin balance in Rover
                previous_total_balance: Uint128,
            },
            /// Requests unlocking of shares for a vault with a lock period
            RequestVaultUnlock {
                account_id: String,
                vault: Vault,
                amount: Uint128,
            },
            /// Withdraws assets from vault for a locked position having a lockup period that has been fulfilled
            ExitVaultUnlocked {
                account_id: String,
                vault: Vault,
                position_id: u64,
            },
            /// Pay back debts of a liquidatable rover account for a bonus
            LiquidateCoin {
                liquidator_account_id: String,
                liquidatee_account_id: String,
                debt_coin: Coin,
                request_coin_denom: String,
            },
            LiquidateVault {
                liquidator_account_id: String,
                liquidatee_account_id: String,
                debt_coin: Coin,
                request_vault: Vault,
                position_type: VaultPositionType,
            },
            /// Perform a swapper with an exact-in amount. Requires slippage allowance %.
            /// If `coin_in.amount: AccountBalance`, the accounts entire balance of `coin_in.denom` will be used.
            SwapExactIn {
                account_id: String,
                coin_in: ActionCoin,
                denom_out: String,
                slippage: Decimal,
            },
            /// Used to update the coin balance of account after an async action
            UpdateCoinBalance {
                /// Account that needs coin balance adjustment
                account_id: String,
                /// Total balance for coin in Rover prior to withdraw
                previous_balance: Coin,
            },
            /// Add Vec<Coin> to liquidity pool in exchange for LP tokens
            ProvideLiquidity {
                account_id: String,
                coins_in: Vec<ActionCoin>,
                lp_token_out: String,
                minimum_receive: Uint128,
            },
            /// Send LP token and withdraw corresponding reserve assets from pool.
            /// If `lp_token.amount: AccountBalance`, the account balance of `lp_token.denom` will be used.
            WithdrawLiquidity {
                account_id: String,
                lp_token: ActionCoin,
            },
            /// Checks to ensure only one vault position is taken per credit account
            AssertOneVaultPositionOnly {
                account_id: String,
            },
            /// Refunds all coin balances back to user wallet
            RefundAllCoinBalances {
                account_id: String,
            },
        }
        ``` */}

    </CH.Code>
</CH.Section>

#### `Health`

<CH.Section>
    <CH.Code>

        ```ts types.ts
        interface Health {
            liquidation_health_factor?: Decimal | null
            liquidation_threshold_adjusted_collateral: Uint128
            max_ltv_adjusted_collateral: Uint128
            max_ltv_health_factor?: Decimal | null
            total_collateral_value: Uint128
            total_debt_value: Uint128
        }
        ```
    </CH.Code>
</CH.Section>

## QueryMsg

### `config`

Rover contract-level config.

<CH.Section>
    <CH.Code>

        ```ts types.ts
        type QueryMsg =
            {
                config: {}
            }
        ```
{/* 
        ```json json
        {
            "config": {}
        }
        ```

        ```rust query.rs
        #[cw_serde]
        #[derive(QueryResponses)]
        pub enum QueryMsg {
            #[returns(ConfigResponse)]
            Config {},
            #[returns(Vec<VaultInfoResponse>)]
            VaultsInfo {
                start_after: Option<VaultUnchecked>,
                limit: Option<u32>,
            },
            #[returns(Vec<String>)]
            AllowedCoins {
                start_after: Option<String>,
                limit: Option<u32>,
            },
            #[returns(Positions)]
            Positions {
                account_id: String,
            },
            #[returns(mars_health::HealthResponse)]
            Health {
                account_id: String,
            },
            #[returns(Vec<CoinBalanceResponseItem>)]
            AllCoinBalances {
                start_after: Option<(String, String)>,
                limit: Option<u32>,
            },
            #[returns(Vec<SharesResponseItem>)]
            AllDebtShares {
                start_after: Option<(String, String)>,
                limit: Option<u32>,
            },
            #[returns(DebtShares)]
            TotalDebtShares(String),
            #[returns(Vec<DebtShares>)]
            AllTotalDebtShares {
                start_after: Option<String>,
                limit: Option<u32>,
            },
            #[returns(Vec<VaultPositionResponseItem>)]
            AllVaultPositions {
                start_after: Option<(String, String)>,
                limit: Option<u32>,
            },
            #[returns(Uint128)]
            TotalVaultCoinBalance {
                vault: VaultUnchecked,
            },
            #[returns(Vec<VaultWithBalance>)]
            AllTotalVaultCoinBalances {
                start_after: Option<VaultUnchecked>,
                limit: Option<u32>,
            },
            #[returns(Uint128)]
            EstimateProvideLiquidity {
                lp_token_out: String,
                coins_in: Vec<Coin>,
            },
            #[returns(Vec<Coin>)]
            EstimateWithdrawLiquidity {
                lp_token: Coin,
            },
        }
        ``` */}

    </CH.Code>
</CH.Section>

{/* #### `ConfigResponse`

<CH.Section>
    <CH.Code>

        ```json json
        {
            "owner": "...",
            "proposed_new_owner": "...",
            "account_nft": "...",
            "red_bank": "...",
            "oracle": "...",
            "max_close_factor": "0.123",
            "max_unlocking_positions": "12345",
            "swapper": "...",
            "zapper": "..."
        }
        ```

        ```rust query.rs
        #[cw_serde]
        pub struct ConfigResponse {
            pub owner: Option<String>,
            pub proposed_new_owner: Option<String>,
            pub account_nft: Option<String>,
            pub red_bank: String,
            pub oracle: String,
            pub max_close_factor: Decimal,
            pub max_unlocking_positions: Uint128,
            pub swapper: String,
            pub zapper: String,
        }
        ```

    </CH.Code>
</CH.Section> */}

### `vaults_info`

Configs & deposit caps on vaults.

<CH.Section>
    <CH.Code>

        ```ts types.ts
        type QueryMsg =
            {
                vaults_info: {
                    limit?: number | null
                    start_after?: VaultBaseForString | null
                }
            }
        ```

        {/* ```json json
        {
            "vaults_info": {
                "start_after": {
                    "address": "..."
                }, 
                "limit": 5
            }
        }
        ```

        ```rust query.rs
        #[cw_serde]
        #[derive(QueryResponses)]
        pub enum QueryMsg {
            #[returns(ConfigResponse)]
            Config {},
            #[returns(Vec<VaultInfoResponse>)]
            VaultsInfo {
                start_after: Option<VaultUnchecked>,
                limit: Option<u32>,
            },
            #[returns(Vec<String>)]
            AllowedCoins {
                start_after: Option<String>,
                limit: Option<u32>,
            },
            #[returns(Positions)]
            Positions {
                account_id: String,
            },
            #[returns(mars_health::HealthResponse)]
            Health {
                account_id: String,
            },
            #[returns(Vec<CoinBalanceResponseItem>)]
            AllCoinBalances {
                start_after: Option<(String, String)>,
                limit: Option<u32>,
            },
            #[returns(Vec<SharesResponseItem>)]
            AllDebtShares {
                start_after: Option<(String, String)>,
                limit: Option<u32>,
            },
            #[returns(DebtShares)]
            TotalDebtShares(String),
            #[returns(Vec<DebtShares>)]
            AllTotalDebtShares {
                start_after: Option<String>,
                limit: Option<u32>,
            },
            #[returns(Vec<VaultPositionResponseItem>)]
            AllVaultPositions {
                start_after: Option<(String, String)>,
                limit: Option<u32>,
            },
            #[returns(Uint128)]
            TotalVaultCoinBalance {
                vault: VaultUnchecked,
            },
            #[returns(Vec<VaultWithBalance>)]
            AllTotalVaultCoinBalances {
                start_after: Option<VaultUnchecked>,
                limit: Option<u32>,
            },
            #[returns(Uint128)]
            EstimateProvideLiquidity {
                lp_token_out: String,
                coins_in: Vec<Coin>,
            },
            #[returns(Vec<Coin>)]
            EstimateWithdrawLiquidity {
                lp_token: Coin,
            },
        }
        ``` */}

    </CH.Code>
</CH.Section>

{/* Returns a vector containing objects of type [`VaultInfoResponse`](#vaultinforesponse). */}

{/* #### `VaultInfoResponse`

<CH.Section>
    <CH.Code>

        ```json json
        {
            "vault": {
                "address": "..."
            }, 
            "config": {
                "deposit_cap": {
                    "denom": "...", 
                    "amount": "123"
                },
                "max_ltv": "0.123",
                "liquidation_threshold": "0.123",
                "whitelisted": true,  
            }, 
            "utilization": {
                "denom": "...", 
                "amount": "12345"
            }
        }
        ```

        ```rust query.rs
        #[cw_serde]
        pub struct VaultInfoResponse {
            pub vault: VaultUnchecked,
            pub config: VaultConfig,
            /// The amount the vault has been utilized,
            /// denominated in the same denom set in the vault config's deposit cap
            pub utilization: Coin,
        }
        ```

    </CH.Code>
</CH.Section> */}

### `allowed_coins`

Whitelisted coins. 

<CH.Section>
    <CH.Code>

        ```ts types.ts
        type QueryMsg =
            {
                allowed_coins: {
                    limit?: number | null
                    start_after?: string | null
                }
            }
        ```

        {/* ```json json
        {
            "allowed_coins": {
                "start_after": "...", 
                "limit": 5
            }
        }
        ```

        ```rust query.rs
        #[cw_serde]
        #[derive(QueryResponses)]
        pub enum QueryMsg {
            #[returns(ConfigResponse)]
            Config {},
            #[returns(Vec<VaultInfoResponse>)]
            VaultsInfo {
                start_after: Option<VaultUnchecked>,
                limit: Option<u32>,
            },
            #[returns(Vec<String>)]
            AllowedCoins {
                start_after: Option<String>,
                limit: Option<u32>,
            },
            #[returns(Positions)]
            Positions {
                account_id: String,
            },
            #[returns(mars_health::HealthResponse)]
            Health {
                account_id: String,
            },
            #[returns(Vec<CoinBalanceResponseItem>)]
            AllCoinBalances {
                start_after: Option<(String, String)>,
                limit: Option<u32>,
            },
            #[returns(Vec<SharesResponseItem>)]
            AllDebtShares {
                start_after: Option<(String, String)>,
                limit: Option<u32>,
            },
            #[returns(DebtShares)]
            TotalDebtShares(String),
            #[returns(Vec<DebtShares>)]
            AllTotalDebtShares {
                start_after: Option<String>,
                limit: Option<u32>,
            },
            #[returns(Vec<VaultPositionResponseItem>)]
            AllVaultPositions {
                start_after: Option<(String, String)>,
                limit: Option<u32>,
            },
            #[returns(Uint128)]
            TotalVaultCoinBalance {
                vault: VaultUnchecked,
            },
            #[returns(Vec<VaultWithBalance>)]
            AllTotalVaultCoinBalances {
                start_after: Option<VaultUnchecked>,
                limit: Option<u32>,
            },
            #[returns(Uint128)]
            EstimateProvideLiquidity {
                lp_token_out: String,
                coins_in: Vec<Coin>,
            },
            #[returns(Vec<Coin>)]
            EstimateWithdrawLiquidity {
                lp_token: Coin,
            },
        }
        ``` */}

    </CH.Code>
</CH.Section>

{/* Returns a vector containing objects of type `String`.  */}

### `positions`

All positions represented by token with value.

<CH.Section>
    <CH.Code>

        ```ts types.ts
        type QueryMsg =
            {
                positions: {
                    account_id: string
                }
            }
        ```

        {/* ```json json
        {
            "positions": {
                "account_id": "..."
            }
        }
        ```

        ```rust query.rs
        #[cw_serde]
        #[derive(QueryResponses)]
        pub enum QueryMsg {
            #[returns(ConfigResponse)]
            Config {},
            #[returns(Vec<VaultInfoResponse>)]
            VaultsInfo {
                start_after: Option<VaultUnchecked>,
                limit: Option<u32>,
            },
            #[returns(Vec<String>)]
            AllowedCoins {
                start_after: Option<String>,
                limit: Option<u32>,
            },
            #[returns(Positions)]
            Positions {
                account_id: String,
            },
            #[returns(mars_health::HealthResponse)]
            Health {
                account_id: String,
            },
            #[returns(Vec<CoinBalanceResponseItem>)]
            AllCoinBalances {
                start_after: Option<(String, String)>,
                limit: Option<u32>,
            },
            #[returns(Vec<SharesResponseItem>)]
            AllDebtShares {
                start_after: Option<(String, String)>,
                limit: Option<u32>,
            },
            #[returns(DebtShares)]
            TotalDebtShares(String),
            #[returns(Vec<DebtShares>)]
            AllTotalDebtShares {
                start_after: Option<String>,
                limit: Option<u32>,
            },
            #[returns(Vec<VaultPositionResponseItem>)]
            AllVaultPositions {
                start_after: Option<(String, String)>,
                limit: Option<u32>,
            },
            #[returns(Uint128)]
            TotalVaultCoinBalance {
                vault: VaultUnchecked,
            },
            #[returns(Vec<VaultWithBalance>)]
            AllTotalVaultCoinBalances {
                start_after: Option<VaultUnchecked>,
                limit: Option<u32>,
            },
            #[returns(Uint128)]
            EstimateProvideLiquidity {
                lp_token_out: String,
                coins_in: Vec<Coin>,
            },
            #[returns(Vec<Coin>)]
            EstimateWithdrawLiquidity {
                lp_token: Coin,
            },
        }
        ``` */}

    </CH.Code>
</CH.Section>

{/* #### `Positions` (response)

<CH.Section>
    <CH.Code>

        ```json json
        {
            "account_id": "...",
            "deposits": [
                {
                    "denom": "...", 
                    "amount": "12345"
                }, 
                etc...
            ], 
            "debts": [
                {
                    "amount": "12345", 
                    "denom": "...", 
                    "shares": "12345"
                }, 
                etc...
            ], 
            "vaults": [
                {
                    "vault": {
                        "address": "..."
                    }, 
                    "amount": {
                        "unlocked": "12345"
                    }
                }, 
                etc...
            ]
        }
        ```

        ```rust query.rs
        #[cw_serde]
        pub struct Positions {
            pub account_id: String,
            pub deposits: Vec<Coin>,
            pub debts: Vec<DebtAmount>,
            pub vaults: Vec<VaultPosition>,
        }
        ```

    </CH.Code>
</CH.Section> */}

{/* #### `DebtAmount`

<CH.Section>
    <CH.Code>

        ```json json
        {
            "denom": "...", 
            "shares": "12345", 
            "amount": "12345"
        }
        ```

        ```rust query.rs
        #[cw_serde]
        pub struct DebtAmount {
            pub denom: String,
            /// number of shares in debt pool
            pub shares: Uint128,
            /// amount of coins
            pub amount: Uint128,
        }
        ```

    </CH.Code>
</CH.Section> */}

{/* #### `VaultPosition`

<CH.Section>
    <CH.Code>

        ```json json
        {
            "vault": {
                "address": "..."
            }, 
            "amount": {
                "unlocked": "12345"
            }
        }
        ```

        ```rust position.rs
        #[cw_serde]
        pub struct VaultPosition {
            pub vault: Vault,
            pub amount: VaultPositionAmount,
        }
        ```

    </CH.Code>
</CH.Section>

#### `VaultPositionAmount`

<CH.Section>
    <CH.Code>

        ```rust amount.rs
        #[cw_serde]
        pub enum VaultPositionAmount {
            Unlocked(VaultAmount),
            Locking(LockingVaultAmount),
        }
        ```

    </CH.Code>
</CH.Section> */}

### `health`

The health of the account represented by token.

<CH.Section>
    <CH.Code>

        ```ts types.ts
        type QueryMsg =
            {
                health: {
                    account_id: string
                }
            }
        ```

        {/* ```json json
        {
            "health": {
                "account_id": "..."
            }
        }
        ```

        ```rust query.rs
        #[cw_serde]
        #[derive(QueryResponses)]
        pub enum QueryMsg {
            #[returns(ConfigResponse)]
            Config {},
            #[returns(Vec<VaultInfoResponse>)]
            VaultsInfo {
                start_after: Option<VaultUnchecked>,
                limit: Option<u32>,
            },
            #[returns(Vec<String>)]
            AllowedCoins {
                start_after: Option<String>,
                limit: Option<u32>,
            },
            #[returns(Positions)]
            Positions {
                account_id: String,
            },
            #[returns(mars_health::HealthResponse)]
            Health {
                account_id: String,
            },
            #[returns(Vec<CoinBalanceResponseItem>)]
            AllCoinBalances {
                start_after: Option<(String, String)>,
                limit: Option<u32>,
            },
            #[returns(Vec<SharesResponseItem>)]
            AllDebtShares {
                start_after: Option<(String, String)>,
                limit: Option<u32>,
            },
            #[returns(DebtShares)]
            TotalDebtShares(String),
            #[returns(Vec<DebtShares>)]
            AllTotalDebtShares {
                start_after: Option<String>,
                limit: Option<u32>,
            },
            #[returns(Vec<VaultPositionResponseItem>)]
            AllVaultPositions {
                start_after: Option<(String, String)>,
                limit: Option<u32>,
            },
            #[returns(Uint128)]
            TotalVaultCoinBalance {
                vault: VaultUnchecked,
            },
            #[returns(Vec<VaultWithBalance>)]
            AllTotalVaultCoinBalances {
                start_after: Option<VaultUnchecked>,
                limit: Option<u32>,
            },
            #[returns(Uint128)]
            EstimateProvideLiquidity {
                lp_token_out: String,
                coins_in: Vec<Coin>,
            },
            #[returns(Vec<Coin>)]
            EstimateWithdrawLiquidity {
                lp_token: Coin,
            },
        }
        ``` */}

    </CH.Code>
</CH.Section>

{/* #### `HealthResponse`

<CH.Section>
    <CH.Code>

        ```json json 
        {
            "total_debt_value": "12345",
            "total_collateral_value": "12345",
            "max_ltv_adjusted_collateral": "12456",
            "liquidation_threshold_adjusted_collateral": "12345",
            "max_ltv_health_factor": "0.123",
            "liquidation_health_factor": "0.123",
            "liquidatable": true,
            "above_max_ltv": true
        }
        ```

        ```rust health.rs
        #[cw_serde]
        pub struct HealthResponse {
            pub total_debt_value: Uint128,
            pub total_collateral_value: Uint128,
            pub max_ltv_adjusted_collateral: Uint128,
            pub liquidation_threshold_adjusted_collateral: Uint128,
            pub max_ltv_health_factor: Option<Decimal>,
            pub liquidation_health_factor: Option<Decimal>,
            pub liquidatable: bool,
            pub above_max_ltv: bool,
        }
        ```

    </CH.Code>
</CH.Section> */}

### `all_coin_balances`

Enumerate coin balances for all token positions; `start_after` accepts (`account_id`, `denom`).

<CH.Section>
    <CH.Code>

        ```ts types.ts
        type QueryMsg =
            {
                all_coin_balances: {
                    limit?: number | null
                    start_after?: [string, string] | null
                }
            }
        ```

        {/* ```json json
        {
            "all_coin_balances": {
                "start_after": [ "...", "..." ],
                "limit": 5
            }
        }
        ```

        ```rust query.rs
        #[cw_serde]
        #[derive(QueryResponses)]
        pub enum QueryMsg {
            #[returns(ConfigResponse)]
            Config {},
            #[returns(Vec<VaultInfoResponse>)]
            VaultsInfo {
                start_after: Option<VaultUnchecked>,
                limit: Option<u32>,
            },
            #[returns(Vec<String>)]
            AllowedCoins {
                start_after: Option<String>,
                limit: Option<u32>,
            },
            #[returns(Positions)]
            Positions {
                account_id: String,
            },
            #[returns(mars_health::HealthResponse)]
            Health {
                account_id: String,
            },
            #[returns(Vec<CoinBalanceResponseItem>)]
            AllCoinBalances {
                start_after: Option<(String, String)>,
                limit: Option<u32>,
            },
            #[returns(Vec<SharesResponseItem>)]
            AllDebtShares {
                start_after: Option<(String, String)>,
                limit: Option<u32>,
            },
            #[returns(DebtShares)]
            TotalDebtShares(String),
            #[returns(Vec<DebtShares>)]
            AllTotalDebtShares {
                start_after: Option<String>,
                limit: Option<u32>,
            },
            #[returns(Vec<VaultPositionResponseItem>)]
            AllVaultPositions {
                start_after: Option<(String, String)>,
                limit: Option<u32>,
            },
            #[returns(Uint128)]
            TotalVaultCoinBalance {
                vault: VaultUnchecked,
            },
            #[returns(Vec<VaultWithBalance>)]
            AllTotalVaultCoinBalances {
                start_after: Option<VaultUnchecked>,
                limit: Option<u32>,
            },
            #[returns(Uint128)]
            EstimateProvideLiquidity {
                lp_token_out: String,
                coins_in: Vec<Coin>,
            },
            #[returns(Vec<Coin>)]
            EstimateWithdrawLiquidity {
                lp_token: Coin,
            },
        }
        ``` */}

    </CH.Code>
</CH.Section>

{/* Returns a vector containing objects of type [`CoinBalanceResponseItem`](#coinbalanceresponseitem). */}

{/* #### `CoinBalanceResponseItem`

<CH.Section>
    <CH.Code>

        ```json json
        {
            "account_id": "...", 
            "denom": "...", 
            "amount": "12345"
        }
        ```

        ```rust query.rs
        #[cw_serde]
        pub struct CoinBalanceResponseItem {
            pub account_id: String,
            pub denom: String,
            pub amount: Uint128,
        }
        ```

    </CH.Code>
</CH.Section> */}

### `all_debt_shares`

Enumerate debt shares for all token positions; `start_after` accepts (`account_id`, `denom`).

<CH.Section>
    <CH.Code>

        ```ts types.ts
        type QueryMsg =
            {
                all_debt_shares: {
                    limit?: number | null
                    start_after?: [string, string] | null
                }
            }
        ```

        {/* ```json json
        {
            "all_debt_shares": {
                "start_after": [ "...", "..." ],
                "limit": 5
            }
        }
        ```

        ```rust query.rs
        #[cw_serde]
        #[derive(QueryResponses)]
        pub enum QueryMsg {
            #[returns(ConfigResponse)]
            Config {},
            #[returns(Vec<VaultInfoResponse>)]
            VaultsInfo {
                start_after: Option<VaultUnchecked>,
                limit: Option<u32>,
            },
            #[returns(Vec<String>)]
            AllowedCoins {
                start_after: Option<String>,
                limit: Option<u32>,
            },
            #[returns(Positions)]
            Positions {
                account_id: String,
            },
            #[returns(mars_health::HealthResponse)]
            Health {
                account_id: String,
            },
            #[returns(Vec<CoinBalanceResponseItem>)]
            AllCoinBalances {
                start_after: Option<(String, String)>,
                limit: Option<u32>,
            },
            #[returns(Vec<SharesResponseItem>)]
            AllDebtShares {
                start_after: Option<(String, String)>,
                limit: Option<u32>,
            },
            #[returns(DebtShares)]
            TotalDebtShares(String),
            #[returns(Vec<DebtShares>)]
            AllTotalDebtShares {
                start_after: Option<String>,
                limit: Option<u32>,
            },
            #[returns(Vec<VaultPositionResponseItem>)]
            AllVaultPositions {
                start_after: Option<(String, String)>,
                limit: Option<u32>,
            },
            #[returns(Uint128)]
            TotalVaultCoinBalance {
                vault: VaultUnchecked,
            },
            #[returns(Vec<VaultWithBalance>)]
            AllTotalVaultCoinBalances {
                start_after: Option<VaultUnchecked>,
                limit: Option<u32>,
            },
            #[returns(Uint128)]
            EstimateProvideLiquidity {
                lp_token_out: String,
                coins_in: Vec<Coin>,
            },
            #[returns(Vec<Coin>)]
            EstimateWithdrawLiquidity {
                lp_token: Coin,
            },
        }
        ``` */}

    </CH.Code>
</CH.Section>

{/* Returns a vector containing objects of type [`SharesResponseItem`](#sharesresponseitem). */}

{/* #### `SharesResponseItem`

<CH.Section>
    <CH.Code>

        ```json json
        {
            "account_id": "...", 
            "denom": "...", 
            "shares": "12345"
        }
        ```

        ```rust query.rs
        #[cw_serde]
        pub struct SharesResponseItem {
            pub account_id: String,
            pub denom: String,
            pub shares: Uint128,
        }
        ```

    </CH.Code>
</CH.Section> */}


### `total_debt_shares`

Total debt shares issued for Coin.

<CH.Section>
    <CH.Code>

        ```ts types.ts
        type QueryMsg =
            {
                total_debt_shares: string
            }
        ```

        {/* ```json json
        {
            "total_debt_shares": "..."
        }
        ```

        ```rust query.rs
        #[cw_serde]
        #[derive(QueryResponses)]
        pub enum QueryMsg {
            #[returns(ConfigResponse)]
            Config {},
            #[returns(Vec<VaultInfoResponse>)]
            VaultsInfo {
                start_after: Option<VaultUnchecked>,
                limit: Option<u32>,
            },
            #[returns(Vec<String>)]
            AllowedCoins {
                start_after: Option<String>,
                limit: Option<u32>,
            },
            #[returns(Positions)]
            Positions {
                account_id: String,
            },
            #[returns(mars_health::HealthResponse)]
            Health {
                account_id: String,
            },
            #[returns(Vec<CoinBalanceResponseItem>)]
            AllCoinBalances {
                start_after: Option<(String, String)>,
                limit: Option<u32>,
            },
            #[returns(Vec<SharesResponseItem>)]
            AllDebtShares {
                start_after: Option<(String, String)>,
                limit: Option<u32>,
            },
            #[returns(DebtShares)]
            TotalDebtShares(String),
            #[returns(Vec<DebtShares>)]
            AllTotalDebtShares {
                start_after: Option<String>,
                limit: Option<u32>,
            },
            #[returns(Vec<VaultPositionResponseItem>)]
            AllVaultPositions {
                start_after: Option<(String, String)>,
                limit: Option<u32>,
            },
            #[returns(Uint128)]
            TotalVaultCoinBalance {
                vault: VaultUnchecked,
            },
            #[returns(Vec<VaultWithBalance>)]
            AllTotalVaultCoinBalances {
                start_after: Option<VaultUnchecked>,
                limit: Option<u32>,
            },
            #[returns(Uint128)]
            EstimateProvideLiquidity {
                lp_token_out: String,
                coins_in: Vec<Coin>,
            },
            #[returns(Vec<Coin>)]
            EstimateWithdrawLiquidity {
                lp_token: Coin,
            },
        }
        ``` */}

    </CH.Code>
</CH.Section>

{/* #### `DebtShares` (response)

<CH.Section>
    <CH.Code>

        ```json json
        {
            "denom": "...", 
            "shares": "12345"
        }
        ```

        ```rust query.rs
        #[cw_serde]
        pub struct DebtShares {
            pub denom: String,
            pub shares: Uint128,
        }
        ```

    </CH.Code>
</CH.Section> */}

### `all_total_debt_shares`

Enumerate total debt shares for all supported coins; start_after accepts denom string.

<CH.Section>
    <CH.Code>

        ```ts types.ts
        type QueryMsg =
            {
                all_total_debt_shares: {
                    limit?: number | null
                    start_after?: string | null
                }
            }
        ```

        {/* ```json json
        {
            "all_total_debt_shares": {
                "start_after": "...",
                "limit": 5
            }
        }
        ```

        ```rust query.rs
        #[cw_serde]
        #[derive(QueryResponses)]
        pub enum QueryMsg {
            #[returns(ConfigResponse)]
            Config {},
            #[returns(Vec<VaultInfoResponse>)]
            VaultsInfo {
                start_after: Option<VaultUnchecked>,
                limit: Option<u32>,
            },
            #[returns(Vec<String>)]
            AllowedCoins {
                start_after: Option<String>,
                limit: Option<u32>,
            },
            #[returns(Positions)]
            Positions {
                account_id: String,
            },
            #[returns(mars_health::HealthResponse)]
            Health {
                account_id: String,
            },
            #[returns(Vec<CoinBalanceResponseItem>)]
            AllCoinBalances {
                start_after: Option<(String, String)>,
                limit: Option<u32>,
            },
            #[returns(Vec<SharesResponseItem>)]
            AllDebtShares {
                start_after: Option<(String, String)>,
                limit: Option<u32>,
            },
            #[returns(DebtShares)]
            TotalDebtShares(String),
            #[returns(Vec<DebtShares>)]
            AllTotalDebtShares {
                start_after: Option<String>,
                limit: Option<u32>,
            },
            #[returns(Vec<VaultPositionResponseItem>)]
            AllVaultPositions {
                start_after: Option<(String, String)>,
                limit: Option<u32>,
            },
            #[returns(Uint128)]
            TotalVaultCoinBalance {
                vault: VaultUnchecked,
            },
            #[returns(Vec<VaultWithBalance>)]
            AllTotalVaultCoinBalances {
                start_after: Option<VaultUnchecked>,
                limit: Option<u32>,
            },
            #[returns(Uint128)]
            EstimateProvideLiquidity {
                lp_token_out: String,
                coins_in: Vec<Coin>,
            },
            #[returns(Vec<Coin>)]
            EstimateWithdrawLiquidity {
                lp_token: Coin,
            },
        }
        ``` */}

    </CH.Code>
</CH.Section>

{/* Returns a vector containing objects of type [`DebtShares`](#debtshares). */}

### `all_vault_positions`

Enumerate all vault positions; start_after accepts (account_id, addr).

<CH.Section>
    <CH.Code>

        ```ts types.ts
        type QueryMsg =
            {
                all_vault_positions: {
                    limit?: number | null
                    start_after?: [string, string] | null
                }
            }
        ```

        {/* ```json json
        {
            "all_vault_positions": {
                "start_after": [ "...", "..." ],
                "limit": 5  
            }
        }
        ```

        ```rust query.rs
        #[cw_serde]
        #[derive(QueryResponses)]
        pub enum QueryMsg {
            #[returns(ConfigResponse)]
            Config {},
            #[returns(Vec<VaultInfoResponse>)]
            VaultsInfo {
                start_after: Option<VaultUnchecked>,
                limit: Option<u32>,
            },
            #[returns(Vec<String>)]
            AllowedCoins {
                start_after: Option<String>,
                limit: Option<u32>,
            },
            #[returns(Positions)]
            Positions {
                account_id: String,
            },
            #[returns(mars_health::HealthResponse)]
            Health {
                account_id: String,
            },
            #[returns(Vec<CoinBalanceResponseItem>)]
            AllCoinBalances {
                start_after: Option<(String, String)>,
                limit: Option<u32>,
            },
            #[returns(Vec<SharesResponseItem>)]
            AllDebtShares {
                start_after: Option<(String, String)>,
                limit: Option<u32>,
            },
            #[returns(DebtShares)]
            TotalDebtShares(String),
            #[returns(Vec<DebtShares>)]
            AllTotalDebtShares {
                start_after: Option<String>,
                limit: Option<u32>,
            },
            #[returns(Vec<VaultPositionResponseItem>)]
            AllVaultPositions {
                start_after: Option<(String, String)>,
                limit: Option<u32>,
            },
            #[returns(Uint128)]
            TotalVaultCoinBalance {
                vault: VaultUnchecked,
            },
            #[returns(Vec<VaultWithBalance>)]
            AllTotalVaultCoinBalances {
                start_after: Option<VaultUnchecked>,
                limit: Option<u32>,
            },
            #[returns(Uint128)]
            EstimateProvideLiquidity {
                lp_token_out: String,
                coins_in: Vec<Coin>,
            },
            #[returns(Vec<Coin>)]
            EstimateWithdrawLiquidity {
                lp_token: Coin,
            },
        }
        ``` */}

    </CH.Code>
</CH.Section>

{/* Returns a vector containing objects of type [`VaultPositionResponseItem`](#vaultpositionresponseitem). */}

{/* #### `VaultPositionResponseItem`

<CH.Section>
    <CH.Code>

        ```json json
        {
            "account_id": "...", 
            "position": {
                "vault": {
                    "address": "..."
                }, 
                "amount": {
                    "unlocked": "12345"
                }
            }
        }
        ```

        ```rust query.rs
        #[cw_serde]
        pub struct VaultPositionResponseItem {
            pub account_id: String,
            pub position: VaultPosition,
        }
        ```

    </CH.Code>
</CH.Section> */}

### `total_vault_coin_balance`

Get total vault coin balance in Rover for vault.

<CH.Section>
    <CH.Code>

        ```ts types.ts
        type QueryMsg =
            {
                total_vault_coin_balance: {
                    vault: VaultBaseForString
                }
            }
        ```

        {/* ```json json
        {
            "total_vault_coin_balance": {
                "vault": {
                    "address": "..."
                }
            }
        }
        ```

        ```rust query.rs
        #[cw_serde]
        #[derive(QueryResponses)]
        pub enum QueryMsg {
            #[returns(ConfigResponse)]
            Config {},
            #[returns(Vec<VaultInfoResponse>)]
            VaultsInfo {
                start_after: Option<VaultUnchecked>,
                limit: Option<u32>,
            },
            #[returns(Vec<String>)]
            AllowedCoins {
                start_after: Option<String>,
                limit: Option<u32>,
            },
            #[returns(Positions)]
            Positions {
                account_id: String,
            },
            #[returns(mars_health::HealthResponse)]
            Health {
                account_id: String,
            },
            #[returns(Vec<CoinBalanceResponseItem>)]
            AllCoinBalances {
                start_after: Option<(String, String)>,
                limit: Option<u32>,
            },
            #[returns(Vec<SharesResponseItem>)]
            AllDebtShares {
                start_after: Option<(String, String)>,
                limit: Option<u32>,
            },
            #[returns(DebtShares)]
            TotalDebtShares(String),
            #[returns(Vec<DebtShares>)]
            AllTotalDebtShares {
                start_after: Option<String>,
                limit: Option<u32>,
            },
            #[returns(Vec<VaultPositionResponseItem>)]
            AllVaultPositions {
                start_after: Option<(String, String)>,
                limit: Option<u32>,
            },
            #[returns(Uint128)]
            TotalVaultCoinBalance {
                vault: VaultUnchecked,
            },
            #[returns(Vec<VaultWithBalance>)]
            AllTotalVaultCoinBalances {
                start_after: Option<VaultUnchecked>,
                limit: Option<u32>,
            },
            #[returns(Uint128)]
            EstimateProvideLiquidity {
                lp_token_out: String,
                coins_in: Vec<Coin>,
            },
            #[returns(Vec<Coin>)]
            EstimateWithdrawLiquidity {
                lp_token: Coin,
            },
        }
        ``` */}

    </CH.Code>
</CH.Section>

{/* Returns `Uint128`. */}

### `all_total_vault_coin_balances`

Enumerate all total vault coin balances; start_after accepts vault addr.

<CH.Section>
    <CH.Code>

        ```ts types.ts
        type QueryMsg =
            {
                all_total_vault_coin_balances: {
                    limit?: number | null
                    start_after?: VaultBaseForString | null
                }
            }
        ```

        {/* ```json json
        {
            "all_total_vault_coin_balances": {
                "start_after": {
                    "address": "..."
                }, 
                "limit": 5
            }
        }
        ```

        ```rust query.rs
        #[cw_serde]
        #[derive(QueryResponses)]
        pub enum QueryMsg {
            #[returns(ConfigResponse)]
            Config {},
            #[returns(Vec<VaultInfoResponse>)]
            VaultsInfo {
                start_after: Option<VaultUnchecked>,
                limit: Option<u32>,
            },
            #[returns(Vec<String>)]
            AllowedCoins {
                start_after: Option<String>,
                limit: Option<u32>,
            },
            #[returns(Positions)]
            Positions {
                account_id: String,
            },
            #[returns(mars_health::HealthResponse)]
            Health {
                account_id: String,
            },
            #[returns(Vec<CoinBalanceResponseItem>)]
            AllCoinBalances {
                start_after: Option<(String, String)>,
                limit: Option<u32>,
            },
            #[returns(Vec<SharesResponseItem>)]
            AllDebtShares {
                start_after: Option<(String, String)>,
                limit: Option<u32>,
            },
            #[returns(DebtShares)]
            TotalDebtShares(String),
            #[returns(Vec<DebtShares>)]
            AllTotalDebtShares {
                start_after: Option<String>,
                limit: Option<u32>,
            },
            #[returns(Vec<VaultPositionResponseItem>)]
            AllVaultPositions {
                start_after: Option<(String, String)>,
                limit: Option<u32>,
            },
            #[returns(Uint128)]
            TotalVaultCoinBalance {
                vault: VaultUnchecked,
            },
            #[returns(Vec<VaultWithBalance>)]
            AllTotalVaultCoinBalances {
                start_after: Option<VaultUnchecked>,
                limit: Option<u32>,
            },
            #[returns(Uint128)]
            EstimateProvideLiquidity {
                lp_token_out: String,
                coins_in: Vec<Coin>,
            },
            #[returns(Vec<Coin>)]
            EstimateWithdrawLiquidity {
                lp_token: Coin,
            },
        }
        ``` */}

    </CH.Code>
</CH.Section>

{/* Returns a vector containing objects of type `VaultWithBalance`.

#### `VaultWithBalance`

<CH.Section>
    <CH.Code>

        ```json json
        {
            "vault": {
                "address": "..."
            }, 
            "balance": "12345"
        }
        ```

        ```rust query.rs
        #[cw_serde]
        pub struct VaultWithBalance {
            pub vault: Vault,
            pub balance: Uint128,
        }
        ```

    </CH.Code>
</CH.Section> */}

### `estimate_provide_liquidity`

Estimate how many LP tokens received in exchange for coins provided for liquidity.

<CH.Section>
    <CH.Code>

        ```ts types.ts
        type QueryMsg =
            {
                estimate_provide_liquidity: {
                    coins_in: Coin[]
                    lp_token_out: string
                }
            }
        ```

        {/* ```json json
        {
            "estimate_provide_liquidity": {
                "lp_token_out": "...", 
                "coins_in": [
                    {
                        "denom": "...", 
                        "amount": "12345"
                    }, 
                    etc...
                ]
            }
        }
        ```

        ```rust query.rs
        #[cw_serde]
        #[derive(QueryResponses)]
        pub enum QueryMsg {
            #[returns(ConfigResponse)]
            Config {},
            #[returns(Vec<VaultInfoResponse>)]
            VaultsInfo {
                start_after: Option<VaultUnchecked>,
                limit: Option<u32>,
            },
            #[returns(Vec<String>)]
            AllowedCoins {
                start_after: Option<String>,
                limit: Option<u32>,
            },
            #[returns(Positions)]
            Positions {
                account_id: String,
            },
            #[returns(mars_health::HealthResponse)]
            Health {
                account_id: String,
            },
            #[returns(Vec<CoinBalanceResponseItem>)]
            AllCoinBalances {
                start_after: Option<(String, String)>,
                limit: Option<u32>,
            },
            #[returns(Vec<SharesResponseItem>)]
            AllDebtShares {
                start_after: Option<(String, String)>,
                limit: Option<u32>,
            },
            #[returns(DebtShares)]
            TotalDebtShares(String),
            #[returns(Vec<DebtShares>)]
            AllTotalDebtShares {
                start_after: Option<String>,
                limit: Option<u32>,
            },
            #[returns(Vec<VaultPositionResponseItem>)]
            AllVaultPositions {
                start_after: Option<(String, String)>,
                limit: Option<u32>,
            },
            #[returns(Uint128)]
            TotalVaultCoinBalance {
                vault: VaultUnchecked,
            },
            #[returns(Vec<VaultWithBalance>)]
            AllTotalVaultCoinBalances {
                start_after: Option<VaultUnchecked>,
                limit: Option<u32>,
            },
            #[returns(Uint128)]
            EstimateProvideLiquidity {
                lp_token_out: String,
                coins_in: Vec<Coin>,
            },
            #[returns(Vec<Coin>)]
            EstimateWithdrawLiquidity {
                lp_token: Coin,
            },
        }
        ``` */}

    </CH.Code>
</CH.Section>

{/* Returns `Uint128`. */}

### `estimate_withdraw_liquidity`

Estimate coins withdrawn if exchanged for LP tokens.

<CH.Section>
    <CH.Code>

        ```ts types.ts
        type QueryMsg =
            {
                estimate_withdraw_liquidity: {
                    lp_token: Coin
                }
            }
        ```

        {/* ```json json
        {
            "estimate_withdraw_liquidity": {
                "lp_token": {
                    "denom": "...", 
                    "amount": "12345"
                }
            }
        }
        ```

        ```rust query.rs
        #[cw_serde]
        #[derive(QueryResponses)]
        pub enum QueryMsg {
            #[returns(ConfigResponse)]
            Config {},
            #[returns(Vec<VaultInfoResponse>)]
            VaultsInfo {
                start_after: Option<VaultUnchecked>,
                limit: Option<u32>,
            },
            #[returns(Vec<String>)]
            AllowedCoins {
                start_after: Option<String>,
                limit: Option<u32>,
            },
            #[returns(Positions)]
            Positions {
                account_id: String,
            },
            #[returns(mars_health::HealthResponse)]
            Health {
                account_id: String,
            },
            #[returns(Vec<CoinBalanceResponseItem>)]
            AllCoinBalances {
                start_after: Option<(String, String)>,
                limit: Option<u32>,
            },
            #[returns(Vec<SharesResponseItem>)]
            AllDebtShares {
                start_after: Option<(String, String)>,
                limit: Option<u32>,
            },
            #[returns(DebtShares)]
            TotalDebtShares(String),
            #[returns(Vec<DebtShares>)]
            AllTotalDebtShares {
                start_after: Option<String>,
                limit: Option<u32>,
            },
            #[returns(Vec<VaultPositionResponseItem>)]
            AllVaultPositions {
                start_after: Option<(String, String)>,
                limit: Option<u32>,
            },
            #[returns(Uint128)]
            TotalVaultCoinBalance {
                vault: VaultUnchecked,
            },
            #[returns(Vec<VaultWithBalance>)]
            AllTotalVaultCoinBalances {
                start_after: Option<VaultUnchecked>,
                limit: Option<u32>,
            },
            #[returns(Uint128)]
            EstimateProvideLiquidity {
                lp_token_out: String,
                coins_in: Vec<Coin>,
            },
            #[returns(Vec<Coin>)]
            EstimateWithdrawLiquidity {
                lp_token: Coin,
            },
        }
        ``` */}

    </CH.Code>
</CH.Section>

{/* Returns a vector containing objects of type [`Coin`](https://docs.rs/cosmwasm-std/latest/cosmwasm_std/struct.Coin.html). */}
