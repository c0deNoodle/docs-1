---
sidebar_position: 1
---

# account-nft

## Links

- **Deployments**: https://github.com/mars-protocol/rover/tree/master/scripts/deploy/addresses
- **Types**:
    - **Rust**: https://github.com/mars-protocol/v2-fields-of-mars/tree/master/packages/rover/src/adapters/account_nft/msg
    - **Typescript**: https://github.com/mars-protocol/v2-fields-of-mars/tree/master/scripts/types/generated/mars-account-nft
- **Contract repo**: https://github.com/mars-protocol/v2-fields-of-mars/tree/master/contracts/account-nft
- **Audits**: https://github.com/mars-protocol/mars-audits/tree/main/rover

## InstantiateMsg

<CH.Section>
    <CH.Code>

        ```ts types.ts
        type Uint128 = string

        interface InstantiateMsg {
            max_value_for_burn: Uint128
            minter: string
            name: string
            symbol: string
        }
        ```

        {/* ```json json
        {
            "max_value_for_burn": "123",
            "name": "...", 
            "symbol": "...", 
            "minter": "..."
        }
        ```

        ```rust instantiate.rs
        #[cw_serde]
        pub struct InstantiateMsg {
            pub max_value_for_burn: Uint128,
            pub name: String,
            pub symbol: String,
            pub minter: String,
        }
        ``` */}

    </CH.Code>

{/* | **Params**      | **Type** | **Description** |
| ----------- | ----------- | ----------- |
| [`max_value_for_burn`](focus://json#2)   | `Uint128`        | The maximum value of Debts + Collaterals (denominated in base token) for an account before burns are disallowed for the NFT. Meant to prevent accidental account deletions        |
| [`name`](focus://json#3)   | `String`        | Name of the NFT contract        |
| [`symbol`](focus://json#4)   | `String`        | Symbol of the NFT contract        |
| [`minter`](focus://json#5)   | `String`        | The minter is the only one who can create new NFTs. Initially this likely will be the contract deployer. However, this role should be transferred through a config update to the Credit Manager. It is separate because some blockchains are permissioned and contracts go through governance and are instantiated separately.        | */}

</CH.Section>

## ExecuteMsg

### `update_config`

Update config in storage. Only minter can execute.

<CH.Section>
    <CH.Code>

        ```ts types.ts
        type ExecuteMsg =
            {
                update_config: {
                    updates: NftConfigUpdates
                }
            }
        ```

        {/* ```json json
        {
            "update_config": {
                "updates": {
                    "max_value_for_burn": "123", 
                    "proposed_new_minter": "..."
                }
            }
        }
        ```

        ```rust execute.rs focus=1:5,38
        #[cw_serde]
        pub enum ExecuteMsg {
            UpdateConfig {
                updates: NftConfigUpdates,
            },
            AcceptMinterRole {},
            Mint {
                user: String,
            },
            Burn {
                token_id: String,
            },
            TransferNft {
                recipient: String,
                token_id: String,
            },
            SendNft {
                contract: String,
                token_id: String,
                msg: Binary,
            },
            Approve {
                spender: String,
                token_id: String,
                expires: Option<Expiration>,
            },
            Revoke {
                spender: String,
                token_id: String,
            },
            ApproveAll {
                operator: String,
                expires: Option<Expiration>,
            },
            RevokeAll {
                operator: String,
            },
        }
        ``` */}

    </CH.Code>
</CH.Section>

#### `NftConfigUpdates`

<CH.Section>
    <CH.Code>

        ```ts types.ts
        interface NftConfigUpdates {
            max_value_for_burn?: Uint128 | null
            proposed_new_minter?: string | null
        }
        ```

        {/* ```json json
        {
            "max_value_for_burn": "123", 
            "proposed_new_minter": "..."
        }
        ```

        ```rust nft_config.rs
        #[cw_serde]
        pub struct NftConfigUpdates {
            pub max_value_for_burn: Option<Uint128>,
            pub proposed_new_minter: Option<String>,
        }
        ``` */}

    </CH.Code>
</CH.Section>

### `accept_minter_role`

Accept the proposed minter role. Only the proposed new minter can execute.

<CH.Section>
    <CH.Code>

        ```ts types.ts
        type ExecuteMsg =
            {
                accept_minter_role: {}
            }
        ```

        {/* ```json json
        {
            "accept_minter_role": {}
        }
        ```

        ```rust execute.rs focus=1:2,6,38
        #[cw_serde]
        pub enum ExecuteMsg {
            UpdateConfig {
                updates: NftConfigUpdates,
            },
            AcceptMinterRole {},
            Mint {
                user: String,
            },
            Burn {
                token_id: String,
            },
            TransferNft {
                recipient: String,
                token_id: String,
            },
            SendNft {
                contract: String,
                token_id: String,
                msg: Binary,
            },
            Approve {
                spender: String,
                token_id: String,
                expires: Option<Expiration>,
            },
            Revoke {
                spender: String,
                token_id: String,
            },
            ApproveAll {
                operator: String,
                expires: Option<Expiration>,
            },
            RevokeAll {
                operator: String,
            },
        }
        ``` */}

    </CH.Code>
</CH.Section>

### `mint`

Mint a new NFT to the specified user; can only be called by the contract minter.

<CH.Section>
    <CH.Code>

        ```ts types.ts
        type ExecuteMsg =
            {
                mint: {
                    user: string
                }
            }
        ```

        {/* ```json json
        {
            "mint": {
                "user": "..."
            }
        }
        ```

        ```rust execute.rs focus=1:2,7:9,38
        #[cw_serde]
        pub enum ExecuteMsg {
            UpdateConfig {
                updates: NftConfigUpdates,
            },
            AcceptMinterRole {},
            Mint {
                user: String,
            },
            Burn {
                token_id: String,
            },
            TransferNft {
                recipient: String,
                token_id: String,
            },
            SendNft {
                contract: String,
                token_id: String,
                msg: Binary,
            },
            Approve {
                spender: String,
                token_id: String,
                expires: Option<Expiration>,
            },
            Revoke {
                spender: String,
                token_id: String,
            },
            ApproveAll {
                operator: String,
                expires: Option<Expiration>,
            },
            RevokeAll {
                operator: String,
            },
        }
        ``` */}

    </CH.Code>
</CH.Section>

### `burn`

Burn an NFT the sender has access to. Will attempt to query the Credit Manager first to ensure the balance is below the config set threshold.

<CH.Section>
    <CH.Code>

        ```ts types.ts
        type ExecuteMsg =
            {
                burn: {
                    token_id: string
                }
            }
        ```

        {/* ```json json
        {
            "burn": {
                "token_id": "..."
            }
        }
        ```

        ```rust execute.rs focus=1:2,10:12,38
        #[cw_serde]
        pub enum ExecuteMsg {
            UpdateConfig {
                updates: NftConfigUpdates,
            },
            AcceptMinterRole {},
            Mint {
                user: String,
            },
            Burn {
                token_id: String,
            },
            TransferNft {
                recipient: String,
                token_id: String,
            },
            SendNft {
                contract: String,
                token_id: String,
                msg: Binary,
            },
            Approve {
                spender: String,
                token_id: String,
                expires: Option<Expiration>,
            },
            Revoke {
                spender: String,
                token_id: String,
            },
            ApproveAll {
                operator: String,
                expires: Option<Expiration>,
            },
            RevokeAll {
                operator: String,
            },
        }
        ``` */}

    </CH.Code>
</CH.Section>

## ExecuteMsg (cw721)

### `transfer_nft`

Transfer is a base message to move a token to another account without triggering actions.

<CH.Section>
    <CH.Code>

        ```ts types.ts
        type ExecuteMsg =
            {
                transfer_nft: {
                    recipient: string
                    token_id: string
                }
            }
        ```

        {/* ```json json
        {
            "transfer_nft": {
                "recipient": "...", 
                "token_id": "..."
            }
        }
        ```

        ```rust execute.rs focus=1:2,13:16,38
        #[cw_serde]
        pub enum ExecuteMsg {
            UpdateConfig {
                updates: NftConfigUpdates,
            },
            AcceptMinterRole {},
            Mint {
                user: String,
            },
            Burn {
                token_id: String,
            },
            TransferNft {
                recipient: String,
                token_id: String,
            },
            SendNft {
                contract: String,
                token_id: String,
                msg: Binary,
            },
            Approve {
                spender: String,
                token_id: String,
                expires: Option<Expiration>,
            },
            Revoke {
                spender: String,
                token_id: String,
            },
            ApproveAll {
                operator: String,
                expires: Option<Expiration>,
            },
            RevokeAll {
                operator: String,
            },
        }
        ``` */}

    </CH.Code>
</CH.Section>

### `send_nft`

Send is a base message to transfer a token to a contract and trigger an action on the receiving contract.

<CH.Section>
    <CH.Code>

        ```ts types.ts
        type Binary = string

        type ExecuteMsg =
            {
                send_nft: {
                    contract: string
                    msg: Binary
                    token_id: string
                }
            }
        ```

        {/* ```json json
        {
            "send_nft": {
                "contract": "...", 
                "token": "...", 
                "msg": "<base64_encoded_json_string>"
            }
        }
        ```

        ```rust execute.rs focus=1:2,17:21,38
        #[cw_serde]
        pub enum ExecuteMsg {
            UpdateConfig {
                updates: NftConfigUpdates,
            },
            AcceptMinterRole {},
            Mint {
                user: String,
            },
            Burn {
                token_id: String,
            },
            TransferNft {
                recipient: String,
                token_id: String,
            },
            SendNft {
                contract: String,
                token_id: String,
                msg: Binary,
            },
            Approve {
                spender: String,
                token_id: String,
                expires: Option<Expiration>,
            },
            Revoke {
                spender: String,
                token_id: String,
            },
            ApproveAll {
                operator: String,
                expires: Option<Expiration>,
            },
            RevokeAll {
                operator: String,
            },
        }
        ``` */}

    </CH.Code>
</CH.Section>

### `approve`

Allows operator to transfer/send the token from the owner's account. If expiration is set, then this allowance has a time/height limit.

<CH.Section>
    <CH.Code>

        ```ts types.ts
        type ExecuteMsg =
            {
                approve: {
                    expires?: Expiration | null
                    spender: string
                    token_id: string
                }
            }
        ```

        {/* ```json json
        {
            "approve": {
                "spender": "...",
                "token_id": "...",
                "expires": {
                    "never": {}
                }
            }
        }
        ```

        ```rust execute.rs focus=1:2,22:26,38
        #[cw_serde]
        pub enum ExecuteMsg {
            UpdateConfig {
                updates: NftConfigUpdates,
            },
            AcceptMinterRole {},
            Mint {
                user: String,
            },
            Burn {
                token_id: String,
            },
            TransferNft {
                recipient: String,
                token_id: String,
            },
            SendNft {
                contract: String,
                token_id: String,
                msg: Binary,
            },
            Approve {
                spender: String,
                token_id: String,
                expires: Option<Expiration>,
            },
            Revoke {
                spender: String,
                token_id: String,
            },
            ApproveAll {
                operator: String,
                expires: Option<Expiration>,
            },
            RevokeAll {
                operator: String,
            },
        }
        ``` */}

    </CH.Code>
</CH.Section>

#### `Expiration`

<CH.Section>
    <CH.Code>

        ```ts types.ts
        type Timestamp = Uint64

        type Expiration =
        |   {
                at_height: number
            }
        |   {
                at_time: Timestamp
            }
        |   {
                never: {}
            }
        ```

        {/* ```rust cw_utils
        pub enum Expiration {
            AtHeight(u64),
            AtTime(Timestamp),
            Never {},
        }
        ``` */}

    </CH.Code>
</CH.Section>

### `revoke`

Remove previously granted Approval.

<CH.Section>
    <CH.Code>

        ```ts types.ts
        type ExecuteMsg =
            {
                revoke: {
                    spender: string
                    token_id: string
                }
            }
        ```

        {/* ```json json 
        {
            "revoke": {
                "spender": "...",
                "token_id": "..."
            }
        }
        ```

        ```rust execute.rs focus=1:2,27:30,38
        #[cw_serde]
        pub enum ExecuteMsg {
            UpdateConfig {
                updates: NftConfigUpdates,
            },
            AcceptMinterRole {},
            Mint {
                user: String,
            },
            Burn {
                token_id: String,
            },
            TransferNft {
                recipient: String,
                token_id: String,
            },
            SendNft {
                contract: String,
                token_id: String,
                msg: Binary,
            },
            Approve {
                spender: String,
                token_id: String,
                expires: Option<Expiration>,
            },
            Revoke {
                spender: String,
                token_id: String,
            },
            ApproveAll {
                operator: String,
                expires: Option<Expiration>,
            },
            RevokeAll {
                operator: String,
            },
        }
        ``` */}

    </CH.Code>
</CH.Section>

### `approve_all`

Allows operator to transfer/send any token from the owner's account. If expiration is set, then this allowance has a time/height limit.

<CH.Section>
    <CH.Code>

        ```ts types.ts
        type ExecuteMsg =
            {
                approve_all: {
                    expires?: Expiration | null
                    operator: string
                }
            }
        ```

        {/* ```json json
        {
            "approve_all": {
                "operator": "...",
                "expires": {
                    "never": {}
                } 
            }
        }
        ```

        ```rust execute.rs focus=1:2,31:34,38
        #[cw_serde]
        pub enum ExecuteMsg {
            UpdateConfig {
                updates: NftConfigUpdates,
            },
            AcceptMinterRole {},
            Mint {
                user: String,
            },
            Burn {
                token_id: String,
            },
            TransferNft {
                recipient: String,
                token_id: String,
            },
            SendNft {
                contract: String,
                token_id: String,
                msg: Binary,
            },
            Approve {
                spender: String,
                token_id: String,
                expires: Option<Expiration>,
            },
            Revoke {
                spender: String,
                token_id: String,
            },
            ApproveAll {
                operator: String,
                expires: Option<Expiration>,
            },
            RevokeAll {
                operator: String,
            },
        }
        ``` */}

    </CH.Code>
</CH.Section>

### `revoke_all`

Remove previously granted ApproveAll permission.

<CH.Section>
    <CH.Code>

        ```ts types.ts
        type ExecuteMsg =
            {
                revoke_all: {
                    operator: string
                }
            }
        ```

        {/* ```json json
        {
            "revoke_all": {
                "operator": "..."
            }
        }
        ```

        ```rust execute.rs focus=1:2,35:38
        #[cw_serde]
        pub enum ExecuteMsg {
            UpdateConfig {
                updates: NftConfigUpdates,
            },
            AcceptMinterRole {},
            Mint {
                user: String,
            },
            Burn {
                token_id: String,
            },
            TransferNft {
                recipient: String,
                token_id: String,
            },
            SendNft {
                contract: String,
                token_id: String,
                msg: Binary,
            },
            Approve {
                spender: String,
                token_id: String,
                expires: Option<Expiration>,
            },
            Revoke {
                spender: String,
                token_id: String,
            },
            ApproveAll {
                operator: String,
                expires: Option<Expiration>,
            },
            RevokeAll {
                operator: String,
            },
        }
        ``` */}

    </CH.Code>
</CH.Section>

## QueryMsg

### `config`

Queries the contracts configuration.

<CH.Section>
    <CH.Code>

        ```ts types.ts
        type QueryMsg =
            {
                config: {}
            }
        ```

        {/* ```json json
        {
            "config": {}
        }
        ```

        ```rust query.rs focus=1:5,57
        #[cw_serde]
        #[derive(QueryResponses)]
        pub enum QueryMsg {
            #[returns(crate::adapters::account_nft::UncheckedNftConfig)]
            Config {},
            #[returns(u64)]
            NextId {},
            #[returns(cw721::OwnerOfResponse)]
            OwnerOf {
                token_id: String,
                include_expired: Option<bool>,
            },
            #[returns(cw721::ApprovalResponse)]
            Approval {
                token_id: String,
                spender: String,
                include_expired: Option<bool>,
            },
            #[returns(cw721::ApprovalsResponse)]
            Approvals {
                token_id: String,
                include_expired: Option<bool>,
            },
            #[returns(cw721::OperatorsResponse)]
            AllOperators {
                owner: String,
                include_expired: Option<bool>,
                start_after: Option<String>,
                limit: Option<u32>,
            },
            #[returns(cw721::NumTokensResponse)]
            NumTokens {},
            #[returns(cw721::ContractInfoResponse)]
            ContractInfo {},
            #[returns(cw721::NftInfoResponse<cosmwasm_std::Empty>)]
            NftInfo {
                token_id: String,
            },
            #[returns(cw721::AllNftInfoResponse<cosmwasm_std::Empty>)]
            AllNftInfo {
                token_id: String,
                include_expired: Option<bool>,
            },
            #[returns(cw721::TokensResponse)]
            Tokens {
                owner: String,
                start_after: Option<String>,
                limit: Option<u32>,
            },
            #[returns(cw721::TokensResponse)]
            AllTokens {
                start_after: Option<String>,
                limit: Option<u32>,
            },
            #[returns(cw721_base::MinterResponse)]
            Minter {},
        }
        ``` */}

    </CH.Code>
</CH.Section>

{/* #### `UncheckedNftConfig` (Response)

<CH.Section>
    <CH.Code>

        ```json json
        {
            "max_value_for_burn": "123",
            "proposed_new_minter": "...",
        }
        ```

        ```rust nft_config.rs
        pub type UncheckedNftConfig = NftConfigBase<String>;
        
        #[cw_serde]
        pub struct NftConfigBase<T> {
            pub max_value_for_burn: Uint128,
            pub proposed_new_minter: Option<T>,
        }
        ```
        
    </CH.Code>
</CH.Section> */}

### `next_id`

Queries the next token ID.

<CH.Section>
    <CH.Code>

        ```ts types.ts
        type QueryMsg =
            {
                next_id: {}
            }
        ```

        {/* ```json json
        {
            "next_id": {}
        }
        ```

        ```rust query.rs focus=1:3,6:7,57
        #[cw_serde]
        #[derive(QueryResponses)]
        pub enum QueryMsg {
            #[returns(crate::adapters::account_nft::UncheckedNftConfig)]
            Config {},
            #[returns(u64)]
            NextId {},
            #[returns(cw721::OwnerOfResponse)]
            OwnerOf {
                token_id: String,
                include_expired: Option<bool>,
            },
            #[returns(cw721::ApprovalResponse)]
            Approval {
                token_id: String,
                spender: String,
                include_expired: Option<bool>,
            },
            #[returns(cw721::ApprovalsResponse)]
            Approvals {
                token_id: String,
                include_expired: Option<bool>,
            },
            #[returns(cw721::OperatorsResponse)]
            AllOperators {
                owner: String,
                include_expired: Option<bool>,
                start_after: Option<String>,
                limit: Option<u32>,
            },
            #[returns(cw721::NumTokensResponse)]
            NumTokens {},
            #[returns(cw721::ContractInfoResponse)]
            ContractInfo {},
            #[returns(cw721::NftInfoResponse<cosmwasm_std::Empty>)]
            NftInfo {
                token_id: String,
            },
            #[returns(cw721::AllNftInfoResponse<cosmwasm_std::Empty>)]
            AllNftInfo {
                token_id: String,
                include_expired: Option<bool>,
            },
            #[returns(cw721::TokensResponse)]
            Tokens {
                owner: String,
                start_after: Option<String>,
                limit: Option<u32>,
            },
            #[returns(cw721::TokensResponse)]
            AllTokens {
                start_after: Option<String>,
                limit: Option<u32>,
            },
            #[returns(cw721_base::MinterResponse)]
            Minter {},
        }
        ``` */}

    </CH.Code>
</CH.Section>

{/* Returns `Uint128` */}

## QueryMsg (cw721)

### `owner_of`

Queries the owner of the given token, error if token does not exist.

<CH.Section>
    <CH.Code>

        ```ts types.ts
        type QueryMsg =
            {
                owner_of: {
                    include_expired?: boolean | null
                    token_id: string
                }
            }
        ```

        {/* ```json json
        {
            "owner_of": {
                "token_id": "...", 
                "include_expired": false
            }
        }
        ```

        ```rust query.rs focus=1:3,8:12,57
        #[cw_serde]
        #[derive(QueryResponses)]
        pub enum QueryMsg {
            #[returns(crate::adapters::account_nft::UncheckedNftConfig)]
            Config {},
            #[returns(u64)]
            NextId {},
            #[returns(cw721::OwnerOfResponse)]
            OwnerOf {
                token_id: String,
                include_expired: Option<bool>,
            },
            #[returns(cw721::ApprovalResponse)]
            Approval {
                token_id: String,
                spender: String,
                include_expired: Option<bool>,
            },
            #[returns(cw721::ApprovalsResponse)]
            Approvals {
                token_id: String,
                include_expired: Option<bool>,
            },
            #[returns(cw721::OperatorsResponse)]
            AllOperators {
                owner: String,
                include_expired: Option<bool>,
                start_after: Option<String>,
                limit: Option<u32>,
            },
            #[returns(cw721::NumTokensResponse)]
            NumTokens {},
            #[returns(cw721::ContractInfoResponse)]
            ContractInfo {},
            #[returns(cw721::NftInfoResponse<cosmwasm_std::Empty>)]
            NftInfo {
                token_id: String,
            },
            #[returns(cw721::AllNftInfoResponse<cosmwasm_std::Empty>)]
            AllNftInfo {
                token_id: String,
                include_expired: Option<bool>,
            },
            #[returns(cw721::TokensResponse)]
            Tokens {
                owner: String,
                start_after: Option<String>,
                limit: Option<u32>,
            },
            #[returns(cw721::TokensResponse)]
            AllTokens {
                start_after: Option<String>,
                limit: Option<u32>,
            },
            #[returns(cw721_base::MinterResponse)]
            Minter {},
        }
        ``` */}

    </CH.Code>
</CH.Section>

{/* #### `OwnerOfResponse`

<CH.Section>
    <CH.Code>

        ```json json
        {
            "owner": "...", 
            "approvals": [
                {
                    "spender": "...", 
                    "expires": {
                        "never": {}
                    }
                }, 
                etc...
            ]
        }
        ```

        ```rust query.rs
        #[cw_serde]
        pub struct OwnerOfResponse {
            /// Owner of the token
            pub owner: String,
            /// If set this address is approved to transfer/send the token as well
            pub approvals: Vec<Approval>,
        }
        ```

    </CH.Code>
</CH.Section>

#### `Approval`

<CH.Section>
    <CH.Code>

        ```json json
        {
            "spender": "...", 
            "expires": {
                "never": {}
            }
        }
        ```

        ```rust query.rs
        #[cw_serde]
        pub struct Approval {
            /// Account that can transfer/send the token
            pub spender: String,
            /// When the Approval expires (maybe Expiration::never)
            pub expires: Expiration,
        }
        ```

    </CH.Code>
</CH.Section> */}

### `approval`

Queries the operator that can access all of the owner's tokens.

<CH.Section>
    <CH.Code>

        ```ts types.ts
        type QueryMsg =
            {
                approval: {
                    include_expired?: boolean | null
                    spender: string
                    token_id: string
                }
            }
        ```

        {/* ```json json
        {
            "approval": {
                "token_id": "...",
                "spender": "...",
                "include_expired": false
            }
        }
        ```

        ```rust query.rs focus=1:3,13:18,57
        #[cw_serde]
        #[derive(QueryResponses)]
        pub enum QueryMsg {
            #[returns(crate::adapters::account_nft::UncheckedNftConfig)]
            Config {},
            #[returns(u64)]
            NextId {},
            #[returns(cw721::OwnerOfResponse)]
            OwnerOf {
                token_id: String,
                include_expired: Option<bool>,
            },
            #[returns(cw721::ApprovalResponse)]
            Approval {
                token_id: String,
                spender: String,
                include_expired: Option<bool>,
            },
            #[returns(cw721::ApprovalsResponse)]
            Approvals {
                token_id: String,
                include_expired: Option<bool>,
            },
            #[returns(cw721::OperatorsResponse)]
            AllOperators {
                owner: String,
                include_expired: Option<bool>,
                start_after: Option<String>,
                limit: Option<u32>,
            },
            #[returns(cw721::NumTokensResponse)]
            NumTokens {},
            #[returns(cw721::ContractInfoResponse)]
            ContractInfo {},
            #[returns(cw721::NftInfoResponse<cosmwasm_std::Empty>)]
            NftInfo {
                token_id: String,
            },
            #[returns(cw721::AllNftInfoResponse<cosmwasm_std::Empty>)]
            AllNftInfo {
                token_id: String,
                include_expired: Option<bool>,
            },
            #[returns(cw721::TokensResponse)]
            Tokens {
                owner: String,
                start_after: Option<String>,
                limit: Option<u32>,
            },
            #[returns(cw721::TokensResponse)]
            AllTokens {
                start_after: Option<String>,
                limit: Option<u32>,
            },
            #[returns(cw721_base::MinterResponse)]
            Minter {},
        }
        ``` */}

    </CH.Code>
</CH.Section>

{/* #### `ApprovalResponse`

<CH.Section>
    <CH.Code>

        ```json json
        {
            "approval": {
                "spender": "...", 
                "expires": {
                    "never": {}
                }
            }
        }
        ```

        ```rust query.rs
        #[cw_serde]
        pub struct ApprovalResponse {
            pub approval: Approval,
        }
        ```

    </CH.Code>
</CH.Section> */}

### `approvals`

Queries approvals that a token has.

<CH.Section>
    <CH.Code>

        ```ts types.ts
        type QueryMsg =
            {
                approvals: {
                    include_expired?: boolean | null
                    token_id: string
                }
            }
        ```

        {/* ```json json
        {
            "approvals": {
                "token_id": "...", 
                "include_expired": "false"
            }
        }
        ```

        ```rust query.rs focus=1:3,19:23,57
        #[cw_serde]
        #[derive(QueryResponses)]
        pub enum QueryMsg {
            #[returns(crate::adapters::account_nft::UncheckedNftConfig)]
            Config {},
            #[returns(u64)]
            NextId {},
            #[returns(cw721::OwnerOfResponse)]
            OwnerOf {
                token_id: String,
                include_expired: Option<bool>,
            },
            #[returns(cw721::ApprovalResponse)]
            Approval {
                token_id: String,
                spender: String,
                include_expired: Option<bool>,
            },
            #[returns(cw721::ApprovalsResponse)]
            Approvals {
                token_id: String,
                include_expired: Option<bool>,
            },
            #[returns(cw721::OperatorsResponse)]
            AllOperators {
                owner: String,
                include_expired: Option<bool>,
                start_after: Option<String>,
                limit: Option<u32>,
            },
            #[returns(cw721::NumTokensResponse)]
            NumTokens {},
            #[returns(cw721::ContractInfoResponse)]
            ContractInfo {},
            #[returns(cw721::NftInfoResponse<cosmwasm_std::Empty>)]
            NftInfo {
                token_id: String,
            },
            #[returns(cw721::AllNftInfoResponse<cosmwasm_std::Empty>)]
            AllNftInfo {
                token_id: String,
                include_expired: Option<bool>,
            },
            #[returns(cw721::TokensResponse)]
            Tokens {
                owner: String,
                start_after: Option<String>,
                limit: Option<u32>,
            },
            #[returns(cw721::TokensResponse)]
            AllTokens {
                start_after: Option<String>,
                limit: Option<u32>,
            },
            #[returns(cw721_base::MinterResponse)]
            Minter {},
        }
        ``` */}

    </CH.Code>
</CH.Section>

{/* #### `ApprovalsResponse`

<CH.Section>
    <CH.Code>

        ```json json
        {
            "approvals": [
                {
                    "spender": "...", 
                    "expires": {
                        "never": {}
                    }
                },
                etc...
            ]
        }
        ```

        ```rust query.rs
        #[cw_serde]
        pub struct ApprovalsResponse {
            pub approvals: Vec<Approval>,
        }
        ```

    </CH.Code>
</CH.Section> */}

### `all_operators`

List all operators that can access all of the owner's tokens.

<CH.Section>
    <CH.Code>

        ```ts types.ts
        type QueryMsg =
            {
                all_operators: {
                    include_expired?: boolean | null
                    limit?: number | null
                    owner: string
                    start_after?: string | null
                }
            }
        ```

        {/* ```json json
        {
            "all_operators": {
                "owner": "...",
                "include_expired": false,
                "start_after": "...",
                "limit": 123
            }
        }
        ```

        ```rust query.rs focus=1:3,24:30,57
        #[cw_serde]
        #[derive(QueryResponses)]
        pub enum QueryMsg {
            #[returns(crate::adapters::account_nft::UncheckedNftConfig)]
            Config {},
            #[returns(u64)]
            NextId {},
            #[returns(cw721::OwnerOfResponse)]
            OwnerOf {
                token_id: String,
                include_expired: Option<bool>,
            },
            #[returns(cw721::ApprovalResponse)]
            Approval {
                token_id: String,
                spender: String,
                include_expired: Option<bool>,
            },
            #[returns(cw721::ApprovalsResponse)]
            Approvals {
                token_id: String,
                include_expired: Option<bool>,
            },
            #[returns(cw721::OperatorsResponse)]
            AllOperators {
                owner: String,
                include_expired: Option<bool>,
                start_after: Option<String>,
                limit: Option<u32>,
            },
            #[returns(cw721::NumTokensResponse)]
            NumTokens {},
            #[returns(cw721::ContractInfoResponse)]
            ContractInfo {},
            #[returns(cw721::NftInfoResponse<cosmwasm_std::Empty>)]
            NftInfo {
                token_id: String,
            },
            #[returns(cw721::AllNftInfoResponse<cosmwasm_std::Empty>)]
            AllNftInfo {
                token_id: String,
                include_expired: Option<bool>,
            },
            #[returns(cw721::TokensResponse)]
            Tokens {
                owner: String,
                start_after: Option<String>,
                limit: Option<u32>,
            },
            #[returns(cw721::TokensResponse)]
            AllTokens {
                start_after: Option<String>,
                limit: Option<u32>,
            },
            #[returns(cw721_base::MinterResponse)]
            Minter {},
        }
        ``` */}

    </CH.Code>
</CH.Section>

{/* #### `OperatorsResponse`

<CH.Section>
    <CH.Code>

        ```json json
        {
            "operators": [
                {
                    "spender": "...", 
                    "expires": {
                        "never": {}
                    }
                }, 
                etc...
            ]
        }
        ```

        ```rust query.rs
        #[cw_serde]
        pub struct OperatorsResponse {
            pub operators: Vec<Approval>,
        }
        ```

    </CH.Code>
</CH.Section> */}

### `num_tokens`

Total number of tokens issued.

<CH.Section>
    <CH.Code>

        ```ts types.ts
        type QueryMsg =
            {
                num_tokens: {}
            }
        ```

        {/* ```json json
        {
            "num_tokens": {}
        }
        ```

        ```rust query.rs focus=1:3,31:32,57
        #[cw_serde]
        #[derive(QueryResponses)]
        pub enum QueryMsg {
            #[returns(crate::adapters::account_nft::UncheckedNftConfig)]
            Config {},
            #[returns(u64)]
            NextId {},
            #[returns(cw721::OwnerOfResponse)]
            OwnerOf {
                token_id: String,
                include_expired: Option<bool>,
            },
            #[returns(cw721::ApprovalResponse)]
            Approval {
                token_id: String,
                spender: String,
                include_expired: Option<bool>,
            },
            #[returns(cw721::ApprovalsResponse)]
            Approvals {
                token_id: String,
                include_expired: Option<bool>,
            },
            #[returns(cw721::OperatorsResponse)]
            AllOperators {
                owner: String,
                include_expired: Option<bool>,
                start_after: Option<String>,
                limit: Option<u32>,
            },
            #[returns(cw721::NumTokensResponse)]
            NumTokens {},
            #[returns(cw721::ContractInfoResponse)]
            ContractInfo {},
            #[returns(cw721::NftInfoResponse<cosmwasm_std::Empty>)]
            NftInfo {
                token_id: String,
            },
            #[returns(cw721::AllNftInfoResponse<cosmwasm_std::Empty>)]
            AllNftInfo {
                token_id: String,
                include_expired: Option<bool>,
            },
            #[returns(cw721::TokensResponse)]
            Tokens {
                owner: String,
                start_after: Option<String>,
                limit: Option<u32>,
            },
            #[returns(cw721::TokensResponse)]
            AllTokens {
                start_after: Option<String>,
                limit: Option<u32>,
            },
            #[returns(cw721_base::MinterResponse)]
            Minter {},
        }
        ``` */}

    </CH.Code>
</CH.Section>

{/* #### `NumTokensResponse`

<CH.Section>
    <CH.Code>

        ```json json
        {
            "count": "123"
        }
        ```

        ```rust query.rs
        #[cw_serde]
        pub struct NumTokensResponse {
            pub count: u64,
        }
        ```

    </CH.Code>
</CH.Section> */}

### `contract_info`

Queries top-level metadata about the contract. 

<CH.Section>
    <CH.Code>

        ```ts types.ts
        type QueryMsg =
            {
                contract_info: {}
            }
        ```

        {/* ```json json
        {
            "contract_info": {}
        }
        ```

        ```rust query.rs focus=1:3,33:34,57
        #[cw_serde]
        #[derive(QueryResponses)]
        pub enum QueryMsg {
            #[returns(crate::adapters::account_nft::UncheckedNftConfig)]
            Config {},
            #[returns(u64)]
            NextId {},
            #[returns(cw721::OwnerOfResponse)]
            OwnerOf {
                token_id: String,
                include_expired: Option<bool>,
            },
            #[returns(cw721::ApprovalResponse)]
            Approval {
                token_id: String,
                spender: String,
                include_expired: Option<bool>,
            },
            #[returns(cw721::ApprovalsResponse)]
            Approvals {
                token_id: String,
                include_expired: Option<bool>,
            },
            #[returns(cw721::OperatorsResponse)]
            AllOperators {
                owner: String,
                include_expired: Option<bool>,
                start_after: Option<String>,
                limit: Option<u32>,
            },
            #[returns(cw721::NumTokensResponse)]
            NumTokens {},
            #[returns(cw721::ContractInfoResponse)]
            ContractInfo {},
            #[returns(cw721::NftInfoResponse<cosmwasm_std::Empty>)]
            NftInfo {
                token_id: String,
            },
            #[returns(cw721::AllNftInfoResponse<cosmwasm_std::Empty>)]
            AllNftInfo {
                token_id: String,
                include_expired: Option<bool>,
            },
            #[returns(cw721::TokensResponse)]
            Tokens {
                owner: String,
                start_after: Option<String>,
                limit: Option<u32>,
            },
            #[returns(cw721::TokensResponse)]
            AllTokens {
                start_after: Option<String>,
                limit: Option<u32>,
            },
            #[returns(cw721_base::MinterResponse)]
            Minter {},
        }
        ``` */}

    </CH.Code>
</CH.Section>

{/* #### `ContractInfoResponse`

<CH.Section>
    <CH.Code>

        ```json json
        {
            "name": "...", 
            "symbol": "..."
        }
        ```

        ```rust query.rs
        #[cw_serde]
        pub struct ContractInfoResponse {
            pub name: String,
            pub symbol: String,
        }
        ```

    </CH.Code>
</CH.Section> */}

### `nft_info`

Queries metadata about one particular token, based on ERC721 Metadata JSON Schema but directly from the contract. 

<CH.Section>
    <CH.Code>

        ```ts types.ts
        type QueryMsg =
            {
                nft_info: {
                    token_id: string
                }
            }
        ```

        {/* ```json json
        {
            "token_id": "..."
        }
        ```

        ```rust query.rs focus=1:3,35:38,57
        #[cw_serde]
        #[derive(QueryResponses)]
        pub enum QueryMsg {
            #[returns(crate::adapters::account_nft::UncheckedNftConfig)]
            Config {},
            #[returns(u64)]
            NextId {},
            #[returns(cw721::OwnerOfResponse)]
            OwnerOf {
                token_id: String,
                include_expired: Option<bool>,
            },
            #[returns(cw721::ApprovalResponse)]
            Approval {
                token_id: String,
                spender: String,
                include_expired: Option<bool>,
            },
            #[returns(cw721::ApprovalsResponse)]
            Approvals {
                token_id: String,
                include_expired: Option<bool>,
            },
            #[returns(cw721::OperatorsResponse)]
            AllOperators {
                owner: String,
                include_expired: Option<bool>,
                start_after: Option<String>,
                limit: Option<u32>,
            },
            #[returns(cw721::NumTokensResponse)]
            NumTokens {},
            #[returns(cw721::ContractInfoResponse)]
            ContractInfo {},
            #[returns(cw721::NftInfoResponse<cosmwasm_std::Empty>)]
            NftInfo {
                token_id: String,
            },
            #[returns(cw721::AllNftInfoResponse<cosmwasm_std::Empty>)]
            AllNftInfo {
                token_id: String,
                include_expired: Option<bool>,
            },
            #[returns(cw721::TokensResponse)]
            Tokens {
                owner: String,
                start_after: Option<String>,
                limit: Option<u32>,
            },
            #[returns(cw721::TokensResponse)]
            AllTokens {
                start_after: Option<String>,
                limit: Option<u32>,
            },
            #[returns(cw721_base::MinterResponse)]
            Minter {},
        }
        ``` */}

    </CH.Code>
</CH.Section>

{/* #### `NftInfoResponse<cosmwasm_std::Empty>`

<CH.Section>
    <CH.Code>

        ```json json
        {
            "token_uri": "..."
        }
        ```

        ```rust query.rs
        #[cw_serde]
        pub struct NftInfoResponse<Empty> {
            /// Universal resource identifier for this NFT
            /// Should point to a JSON file that conforms to the ERC721
            /// Metadata JSON Schema
            pub token_uri: Option<String>,
            /// You can add any custom metadata here when you extend cw721-base
            pub extension: Empty,
        }
        ```

    </CH.Code>
</CH.Section> */}

### `all_nft_info`

Returns the result of both `NftInfo` and `OwnerOf` as one query as an optimization for clients. 

<CH.Section>
    <CH.Code>

        ```ts types.ts
        export type QueryMsg =
            {
                all_nft_info: {
                    include_expired?: boolean | null
                    token_id: string
                }
            }
        ```

        {/* ```json json
        {
            "all_nft_info": {
                "token_id": "...",
                "include_expired": false
            }
        }
        ```

        ```rust query.rs focus=1:3,39:43,57
        #[cw_serde]
        #[derive(QueryResponses)]
        pub enum QueryMsg {
            #[returns(crate::adapters::account_nft::UncheckedNftConfig)]
            Config {},
            #[returns(u64)]
            NextId {},
            #[returns(cw721::OwnerOfResponse)]
            OwnerOf {
                token_id: String,
                include_expired: Option<bool>,
            },
            #[returns(cw721::ApprovalResponse)]
            Approval {
                token_id: String,
                spender: String,
                include_expired: Option<bool>,
            },
            #[returns(cw721::ApprovalsResponse)]
            Approvals {
                token_id: String,
                include_expired: Option<bool>,
            },
            #[returns(cw721::OperatorsResponse)]
            AllOperators {
                owner: String,
                include_expired: Option<bool>,
                start_after: Option<String>,
                limit: Option<u32>,
            },
            #[returns(cw721::NumTokensResponse)]
            NumTokens {},
            #[returns(cw721::ContractInfoResponse)]
            ContractInfo {},
            #[returns(cw721::NftInfoResponse<cosmwasm_std::Empty>)]
            NftInfo {
                token_id: String,
            },
            #[returns(cw721::AllNftInfoResponse<cosmwasm_std::Empty>)]
            AllNftInfo {
                token_id: String,
                include_expired: Option<bool>,
            },
            #[returns(cw721::TokensResponse)]
            Tokens {
                owner: String,
                start_after: Option<String>,
                limit: Option<u32>,
            },
            #[returns(cw721::TokensResponse)]
            AllTokens {
                start_after: Option<String>,
                limit: Option<u32>,
            },
            #[returns(cw721_base::MinterResponse)]
            Minter {},
        }
        ``` */}

    </CH.Code>
</CH.Section>

{/* #### `AllNftInfoResponse<cosmwasm_std::Empty>`

<CH.Section>
    <CH.Code>

        ```json json
        {
            "access": {
                "owner": "...", 
                "approvals": [
                    {
                        "spender": "...", 
                        "expires": {
                            "never": {}
                        }
                    }, 
                    etc...
                ]
            }, 
            "info": {
                "token_uri": "..."
            }
        }
        ```

        ```rust query.rs 
        #[cw_serde]
        pub struct AllNftInfoResponse<Empty> {
            /// Who can transfer the token
            pub access: OwnerOfResponse,
            /// Data on the token itself,
            pub info: NftInfoResponse<Empty>,
        }
        ```

    </CH.Code>
</CH.Section> */}

### `tokens`

Queries all tokens owned by the given address, `[]` if unset.

<CH.Section>
    <CH.Code>

        ```ts types.ts
        type QueryMsg =
            {
                tokens: {
                    limit?: number | null
                    owner: string
                    start_after?: string | null
                }
            }
        ```

        {/* ```json json
        {
            "tokens": {
                "owner": "...",
                "start_after": "...",
                "limit": 10
            }
        }
        ```

        ```rust query.rs focus=1:3,44:49,57
        #[cw_serde]
        #[derive(QueryResponses)]
        pub enum QueryMsg {
            #[returns(crate::adapters::account_nft::UncheckedNftConfig)]
            Config {},
            #[returns(u64)]
            NextId {},
            #[returns(cw721::OwnerOfResponse)]
            OwnerOf {
                token_id: String,
                include_expired: Option<bool>,
            },
            #[returns(cw721::ApprovalResponse)]
            Approval {
                token_id: String,
                spender: String,
                include_expired: Option<bool>,
            },
            #[returns(cw721::ApprovalsResponse)]
            Approvals {
                token_id: String,
                include_expired: Option<bool>,
            },
            #[returns(cw721::OperatorsResponse)]
            AllOperators {
                owner: String,
                include_expired: Option<bool>,
                start_after: Option<String>,
                limit: Option<u32>,
            },
            #[returns(cw721::NumTokensResponse)]
            NumTokens {},
            #[returns(cw721::ContractInfoResponse)]
            ContractInfo {},
            #[returns(cw721::NftInfoResponse<cosmwasm_std::Empty>)]
            NftInfo {
                token_id: String,
            },
            #[returns(cw721::AllNftInfoResponse<cosmwasm_std::Empty>)]
            AllNftInfo {
                token_id: String,
                include_expired: Option<bool>,
            },
            #[returns(cw721::TokensResponse)]
            Tokens {
                owner: String,
                start_after: Option<String>,
                limit: Option<u32>,
            },
            #[returns(cw721::TokensResponse)]
            AllTokens {
                start_after: Option<String>,
                limit: Option<u32>,
            },
            #[returns(cw721_base::MinterResponse)]
            Minter {},
        }
        ``` */}

    </CH.Code>
</CH.Section>

{/* #### `TokensResponse`

<CH.Section>
    <CH.Code>

        ```json json
        {
            "tokens": [
                {
                    "...", 
                    "...", 
                    etc...
                }
            ]
        }
        ```

        ```rust query.rs
        #[cw_serde]
        pub struct TokensResponse {
            /// Contains all token_ids in lexicographical ordering
            /// If there are more than `limit`, use `start_from` in future queries
            /// to achieve pagination.
            pub tokens: Vec<String>,
        }
        ```

    </CH.Code>
</CH.Section> */}


### `all_tokens`

Lists all `token_ids` controlled by the contract.

<CH.Section>
    <CH.Code>

        ```ts types.ts
        type QueryMsg =
            {
                all_tokens: {
                    limit?: number | null
                    start_after?: string | null
                }
            }
        ```

        {/* ```json json
        {
            "all_tokens": {
                "start_after": "...",
                "limit": 10
            }
        }
        ```

        ```rust query.rs focus=1:3,50:54,57
        #[cw_serde]
        #[derive(QueryResponses)]
        pub enum QueryMsg {
            #[returns(crate::adapters::account_nft::UncheckedNftConfig)]
            Config {},
            #[returns(u64)]
            NextId {},
            #[returns(cw721::OwnerOfResponse)]
            OwnerOf {
                token_id: String,
                include_expired: Option<bool>,
            },
            #[returns(cw721::ApprovalResponse)]
            Approval {
                token_id: String,
                spender: String,
                include_expired: Option<bool>,
            },
            #[returns(cw721::ApprovalsResponse)]
            Approvals {
                token_id: String,
                include_expired: Option<bool>,
            },
            #[returns(cw721::OperatorsResponse)]
            AllOperators {
                owner: String,
                include_expired: Option<bool>,
                start_after: Option<String>,
                limit: Option<u32>,
            },
            #[returns(cw721::NumTokensResponse)]
            NumTokens {},
            #[returns(cw721::ContractInfoResponse)]
            ContractInfo {},
            #[returns(cw721::NftInfoResponse<cosmwasm_std::Empty>)]
            NftInfo {
                token_id: String,
            },
            #[returns(cw721::AllNftInfoResponse<cosmwasm_std::Empty>)]
            AllNftInfo {
                token_id: String,
                include_expired: Option<bool>,
            },
            #[returns(cw721::TokensResponse)]
            Tokens {
                owner: String,
                start_after: Option<String>,
                limit: Option<u32>,
            },
            #[returns(cw721::TokensResponse)]
            AllTokens {
                start_after: Option<String>,
                limit: Option<u32>,
            },
            #[returns(cw721_base::MinterResponse)]
            Minter {},
        }
        ``` */}

    </CH.Code>
</CH.Section>

{/* Returns [`TokensResponse`](#tokensresponse) */}

### `minter`

Queries the minter.

<CH.Section>
    <CH.Code>

        ```ts types.ts
        type QueryMsg =
            {
                minter: {}
            }
        ```

        {/* ```json json
        {
            "minter": {}
        }
        ```

        ```rust query.rs focus=1:3,55:57
        #[cw_serde]
        #[derive(QueryResponses)]
        pub enum QueryMsg {
            #[returns(crate::adapters::account_nft::UncheckedNftConfig)]
            Config {},
            #[returns(u64)]
            NextId {},
            #[returns(cw721::OwnerOfResponse)]
            OwnerOf {
                token_id: String,
                include_expired: Option<bool>,
            },
            #[returns(cw721::ApprovalResponse)]
            Approval {
                token_id: String,
                spender: String,
                include_expired: Option<bool>,
            },
            #[returns(cw721::ApprovalsResponse)]
            Approvals {
                token_id: String,
                include_expired: Option<bool>,
            },
            #[returns(cw721::OperatorsResponse)]
            AllOperators {
                owner: String,
                include_expired: Option<bool>,
                start_after: Option<String>,
                limit: Option<u32>,
            },
            #[returns(cw721::NumTokensResponse)]
            NumTokens {},
            #[returns(cw721::ContractInfoResponse)]
            ContractInfo {},
            #[returns(cw721::NftInfoResponse<cosmwasm_std::Empty>)]
            NftInfo {
                token_id: String,
            },
            #[returns(cw721::AllNftInfoResponse<cosmwasm_std::Empty>)]
            AllNftInfo {
                token_id: String,
                include_expired: Option<bool>,
            },
            #[returns(cw721::TokensResponse)]
            Tokens {
                owner: String,
                start_after: Option<String>,
                limit: Option<u32>,
            },
            #[returns(cw721::TokensResponse)]
            AllTokens {
                start_after: Option<String>,
                limit: Option<u32>,
            },
            #[returns(cw721_base::MinterResponse)]
            Minter {},
        }
        ``` */}

    </CH.Code>
</CH.Section>

{/* #### `MinterResponse`

<CH.Section>
    <CH.Code>

        ```json json
        {
            "minter": "..."
        }
        ```

        ```rust cw721_base
        pub struct MinterResponse {
            pub minter: String,
        }
        ```

    </CH.Code>
</CH.Section> */}